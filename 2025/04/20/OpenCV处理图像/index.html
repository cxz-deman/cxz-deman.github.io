<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="CXZ">





<title>OpenCV处理图像 | CXZ_note</title>



    <link rel="icon" href="/head.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">CXZ&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">CXZ&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">OpenCV处理图像</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">CXZ</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 20, 2025&nbsp;&nbsp;11:56:22</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><h2 id="1-学前准备"><a href="#1-学前准备" class="headerlink" title="1.学前准备"></a>1.学前准备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install OpenCV-python</span><br></pre></td></tr></table></figure>

<p>测试能否正常使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">print(cv2.__version__)</span><br></pre></td></tr></table></figure>

<h2 id="2-图片基本处理"><a href="#2-图片基本处理" class="headerlink" title="2.图片基本处理"></a>2.图片基本处理</h2><h3 id="2-1图片读取"><a href="#2-1图片读取" class="headerlink" title="2.1图片读取"></a>2.1图片读取</h3><p>cv.imread(文件地址)</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">path = &quot;./imgs/cat1.png&quot;</span><br><span class="line">img=cv.imread(path,cv.IMREAD_COLOR)</span><br><span class="line">cv.imshow(&quot;cat_pic&quot;,img)</span><br><span class="line">h,w,c=img.shape</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="2-2numpy数组转化为图片"><a href="#2-2numpy数组转化为图片" class="headerlink" title="2.2numpy数组转化为图片"></a>2.2numpy数组转化为图片</h3><p>创建一个三维的数组</p>
<p>大小为：height*weight*3（颜色通道），数据类型转化为uint8</p>
<p>img&#x3D;np.zeros((height,width,3),np.uint8)#参数：宽，高，通道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import cv2 </span><br><span class="line">import numpy as np</span><br><span class="line">height,width = 480,640</span><br><span class="line">img=np.zeros((height,width,3),np.uint8)#参数：宽，高，通道</span><br><span class="line">print(img.shape)</span><br><span class="line">img[:,:,:]=np.random.randint(125,255,img.shape)#random.randint参数：随机数范围，图片尺寸</span><br><span class="line">print(img.shape)#打印图片的尺寸</span><br><span class="line">#打印图片维度</span><br><span class="line">print(img.ndim)</span><br><span class="line">cv2.imshow(&quot;img&quot;,img)#显示图片</span><br><span class="line">cv2.waitKey(0)#等待键盘输入</span><br><span class="line">cv2.destroyAllWindows()#销毁所有窗口</span><br></pre></td></tr></table></figure>

<h3 id="2-3在图片里绘制图形"><a href="#2-3在图片里绘制图形" class="headerlink" title="2.3在图片里绘制图形"></a>2.3在图片里绘制图形</h3><h4 id="2-3-1绘制直线"><a href="#2-3-1绘制直线" class="headerlink" title="2.3.1绘制直线"></a>2.3.1绘制直线</h4><p>cv.line(参数：图片，起始点，终止点，颜色，线宽)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">cat=cv.imread(&#x27;./imgs/cat1.png&#x27;)</span><br><span class="line">cv.line(cat,(0,0),(cat.shape[1],cat.shape[0]),(0,255,0),2)#参数：图片，起始点，终止点，颜色，线宽</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2绘制圆形"><a href="#2-3-2绘制圆形" class="headerlink" title="2.3.2绘制圆形"></a>2.3.2绘制圆形</h4><p>cv.cirle(参数：图片，圆心，半径，颜色，线宽 线宽为-1则填充为实心圆)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.circle(cat,(cat.shape[1]//2,cat.shape[0]//2),100,(0,255,0),-1)#参数：图片，圆心，半径，颜色，线宽 线宽为-1则填充为实心圆</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3绘制矩形"><a href="#2-3-3绘制矩形" class="headerlink" title="2.3.3绘制矩形"></a>2.3.3绘制矩形</h4><p>cv.rectangle(参数：图片，左上角点，右下角点，颜色，线宽,-1，填充为实心)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.rectangle(cat,(cat.shape[1],cat.shape[0]),(cat.shape[1]//4*3,cat.shape[0]//4*3),(0,255,0),-1)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4绘制文字（仅英文）"><a href="#2-3-4绘制文字（仅英文）" class="headerlink" title="2.3.4绘制文字（仅英文）"></a>2.3.4绘制文字（仅英文）</h4><p>cv.putText(参数：图片，字，坐标，字体，字体大小，颜色，线宽)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.putText(cat,&#x27;Hello&#x27;,(cat.shape[1]//2,cat.shape[0]//2),cv.FONT_HERSHEY_SIMPLEX,1,(0,0,255),2)</span><br></pre></td></tr></table></figure>

<p>线的类型：#cv.LINE_AA为抗锯齿: cv.LINE_AA, cv.LINE_4, cv.LINE_8, cv.LINE_AA</p>
<h2 id="3-视频处理"><a href="#3-视频处理" class="headerlink" title="3.视频处理"></a>3.视频处理</h2><h3 id="3-1读取视频"><a href="#3-1读取视频" class="headerlink" title="3.1读取视频"></a>3.1读取视频</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">cap=cv.VideoCapture(&#x27;./img/7233x3100 (4).mp4&#x27;)</span><br><span class="line">while True:</span><br><span class="line">    ret,frame=cap.read()#参数为True时，读取下一帧，为False时，读取最后一帧</span><br><span class="line">    if ret==False:</span><br><span class="line">        print(&#x27;读取失败&#x27;)</span><br><span class="line">        break</span><br><span class="line">    cv.imshow(&#x27;frame&#x27;,frame)</span><br><span class="line">    if cv.waitKey(40)&amp;0xFF==ord(&#x27;q&#x27;):#意思：回第八位的值，0xFF为十六进制的FF，即二进制的11111111</span><br><span class="line">        break</span><br><span class="line">cap.release()  </span><br><span class="line">cv.destroyAllWindows()  </span><br></pre></td></tr></table></figure>

<h2 id="4-图像预处理"><a href="#4-图像预处理" class="headerlink" title="4.图像预处理"></a>4.图像预处理</h2><h3 id="4-1图像预处理准备"><a href="#4-1图像预处理准备" class="headerlink" title="4.1图像预处理准备"></a>4.1图像预处理准备</h3><p>读取图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">img=cv.imread(&#x27;./imgs/cat1.png&#x27;)</span><br><span class="line">cv.resize(img,(480,480))</span><br><span class="line">cv.imshow(&#x27;cat&#x27;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-2图像翻转"><a href="#4-2图像翻转" class="headerlink" title="4.2图像翻转"></a>4.2图像翻转</h3><p><strong>cv2.flip(img,flipcode)</strong><br>参数：</p>
<ul>
<li>img: 要翻转的图像</li>
<li>flipcode: 指定翻转类型的标志<ul>
<li>flipcode&#x3D;0: 垂直翻转，图片像素点沿x轴翻转</li>
<li>flipcode&gt;0: 水平翻转，图片像素点沿y轴翻转</li>
<li>flipcode&lt;0: 沿原点翻转，与原图中心对称</li>
</ul>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat_fx=cv.flip(img,0)</span><br><span class="line">cat_fy=cv.flip(img,1)</span><br><span class="line">cat_fxy=cv.flip(img,-1)</span><br><span class="line">cv.imshow(&#x27;cat&#x27;,img)</span><br><span class="line">cv.imshow(&#x27;cat_fx&#x27;,cat_fx)#沿x轴翻转上下</span><br><span class="line">cv.imshow(&#x27;cat_fy&#x27;,cat_fy)#沿y轴翻转左右</span><br><span class="line">cv.imshow(&#x27;cat_fxy&#x27;,cat_fxy)#沿着原点中心翻转</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-3图像仿射变换"><a href="#4-3图像仿射变换" class="headerlink" title="4.3图像仿射变换"></a>4.3<strong>图像仿射变换</strong></h3><p>使用关键仿射变换函数</p>
<p>cv.warpAffline(参数：图片名,仿射变换矩阵,图片大小,插值方法)</p>
<p>得到仿射变换矩阵M –&gt; 带入仿射变换函数 –&gt; 输出</p>
<h4 id="4-3-1图像旋转"><a href="#4-3-1图像旋转" class="headerlink" title="4.3.1图像旋转"></a>4.3.1图像旋转</h4><p>设置参数旋转中心，旋转角度，缩放比例</p>
<p>使用cv.getRotationMatrix2D(设置旋转中心，旋转角度，缩放比例）</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">h,w,_=img.shape</span><br><span class="line">#设置旋转中心</span><br><span class="line">center=(w//2,h//2)</span><br><span class="line">angle=0</span><br><span class="line">scale=0.01#缩放比例</span><br><span class="line">M=cv.getRotationMatrix2D(center,angle,scale)#仿射变换矩阵</span><br><span class="line">#使用仿射变换函数进行变换旋转</span><br><span class="line">img_rotate=cv.warpAffine(img,M,(w,h),flags=cv.INTER_LINEAR)#参数：图片名,仿射变换矩阵,输出图片大小,插值方法</span><br><span class="line">cv.imshow(&#x27;img_rotate&#x27;,img_rotate)</span><br><span class="line">cv.imshow(&#x27;cat&#x27;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2图像平移"><a href="#4-3-2图像平移" class="headerlink" title="4.3.2图像平移"></a>4.3.2图像平移</h4><p>平移：读取图像-》设置参数（平移量tx，ty）-》获取平移矩阵np.float32-》仿射变换函数进行平移-》显示图像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tx = 200</span><br><span class="line">ty = 100</span><br><span class="line">M = np.float32([[1,0,tx],[0,1,ty]])</span><br><span class="line">print(M)</span><br><span class="line"></span><br><span class="line">img_remove = cv.warpAffine(img,M,(w,h))#挪移后多余的像素点舍弃</span><br><span class="line">cv.imshow(&#x27;img_remove&#x27;,img_remove)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3图像缩放"><a href="#4-3-3图像缩放" class="headerlink" title="4.3.3图像缩放"></a>4.3.3图像缩放</h4><p>M仿射矩阵：设置缩放比例</p>
<p>M &#x3D; np.float32([[缩放比例, 0, 0], [0, 缩放比例, 0]])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#读取图像</span><br><span class="line">M = np.float32([[0.1, 0, 0], [0, 0.1, 0]])</span><br><span class="line">img_little = cv.warpAffine(img, M, (img.shape[1], img.shape[0]))</span><br><span class="line">cv.imshow(&#x27;img&#x27;,img_little)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>4.3.4图像剪切</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">import cv2 as cv</span><br><span class="line">#读取图像</span><br><span class="line">shx=0.2</span><br><span class="line">shy=0.2</span><br><span class="line">img=cv.imread(&#x27;./imgs/cat1.png&#x27;)</span><br><span class="line">img=cv.resize(img,(300,300))</span><br><span class="line">M_y = np.float32([[1,shy, 0], [0, 1, 0]])</span><br><span class="line">M_x = np.float32([[1, 0, 0], [shx, 1, 0]])</span><br><span class="line">M_xy= np.float32([[1,shy, 0], [shx, 1, 0]])</span><br><span class="line">M= np.float32([[1,0, 0], [0, 1, 0]])</span><br><span class="line">img_little_y = cv.warpAffine(img, M_y, (360, 360))</span><br><span class="line">img_little_x = cv.warpAffine(img, M_x, (360, 360))</span><br><span class="line">img_little_xy = cv.warpAffine(img, M_xy, (360, 360))</span><br><span class="line">img_li=cv.warpAffine(img, M, (360, 360))</span><br><span class="line">cv.imshow(&#x27;img_y&#x27;,img_little_y)</span><br><span class="line">cv.imshow(&#x27;img_x&#x27;,img_little_x)</span><br><span class="line">cv.imshow(&#x27;img_xy&#x27;,img_little_xy)</span><br><span class="line">cv.imshow(&#x27;img_li&#x27;,img_li)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>4.4图片压缩</p>
<p>4.4.1最近邻插值法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_img=cv.warpAffine(img,M,(300,300),flags=cv.INTER_NEAREST)</span><br><span class="line">cv.imshow(&quot;new_img&quot;,new_img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>4.4.2双线性插值法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_img=cv.warpAffine(img,M,(300,300),flags=cv.INTER_LINEAR)</span><br><span class="line">cv.imshow(&quot;new_img&quot;,new_img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>4.4.3像素区域插值法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">st=cv.imread(&#x27;./img/blackstocking.png&#x27;)</span><br><span class="line">st=cv.resize(st,(160,240))</span><br><span class="line">dst_x=cv.warpAffine(st,M,(160,240),flags=cv.INTER_NEAREST)</span><br><span class="line">dst_l=cv.warpAffine(st,M,(160,240),flags=cv.INTER_LINEAR)</span><br><span class="line">dst_c=cv.warpAffine(st,M,(160,240),flags=cv.INTER_AREA)#像素区域插值</span><br><span class="line">cv.imshow(&#x27;st&#x27;,st)</span><br><span class="line">cv.imshow(&#x27;dst_x&#x27;,dst_x)</span><br><span class="line">cv.imshow(&#x27;dst_l&#x27;,dst_l)</span><br><span class="line">cv.imshow(&#x27;dst_c&#x27;,dst_c)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4其他方法"><a href="#4-3-4其他方法" class="headerlink" title="4.3.4其他方法"></a>4.3.4其他方法</h4><h5 id="4-4-4-1双三次插值法"><a href="#4-4-4-1双三次插值法" class="headerlink" title="4.4.4.1双三次插值法"></a>4.4.4.1双三次插值法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.warpAffine(img,M,(cols,rows),flags=cv.INTER_CUBIC)</span><br></pre></td></tr></table></figure>

<h5 id="4-4-4-2Lanczos插值"><a href="#4-4-4-2Lanczos插值" class="headerlink" title="4.4.4.2Lanczos插值"></a>4.4.4.2Lanczos插值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.warpAffine(img,M,(cols,rows),flags=cv.INTER_LANCZOS4)</span><br></pre></td></tr></table></figure>

<h3 id="4-5图像边缘填充"><a href="#4-5图像边缘填充" class="headerlink" title="4.5图像边缘填充"></a>4.5图像边缘填充</h3><h4 id="4-5-1边缘填充准备"><a href="#4-5-1边缘填充准备" class="headerlink" title="4.5.1边缘填充准备"></a>4.5.1边缘填充准备</h4><p>旋转缩放图像做准备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">face=cv.imread(&quot;./images/face.png&quot;)</span><br><span class="line">#获取旋转矩阵</span><br><span class="line">scale=0.1</span><br><span class="line">angle=45</span><br><span class="line">center=(face.shape[1]//2,face.shape[0]//2)</span><br><span class="line">M=cv.getRotationMatrix2D(center,angle,scale)</span><br><span class="line">#使用仿射变换矩阵</span><br><span class="line">img=cv.warpAffine(face,M,(face.shape[1],face.shape[0]))</span><br><span class="line">cv.imshow(&quot;img&quot;,img)    </span><br><span class="line">cv.imshow(&quot;face&quot;,face)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-2边缘复制"><a href="#4-5-2边缘复制" class="headerlink" title="4.5.2边缘复制"></a>4.5.2边缘复制</h4><p>cv.warpAffine(<strong>参数：图像，输出图片大小，插值方式，边界模式</strong></p>
<p>borderMode&#x3D;cv.BORDER_REPLICATE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img_boradercv=cv.warpAffine(face,M,(face.shape[1],face.shape[0]),cv.INTER_LANCZOS4,borderMode=cv.BORDER_REPLICATE)</span><br><span class="line">cv.imshow(&quot;img&quot;,img)    </span><br><span class="line">cv.imshow(&quot;face&quot;,face)</span><br><span class="line">cv.imshow(&quot;img_boradercv&quot;,img_boradercv)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-3边界反射"><a href="#4-5-3边界反射" class="headerlink" title="4.5.3边界反射"></a>4.5.3边界反射</h4><p>borderMode&#x3D;cv.BORDER_REFLECT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img_reflect = cv.warpAffine(face,M,(face.shape[1],face.shape[0]), cv.INTER_LANCZOS4,borderMode=cv.BORDER_REFLECT)</span><br><span class="line">cv.imshow(&#x27;reflect&#x27;, img_reflect)</span><br><span class="line">cv.imshow(&quot;img&quot;,img)    </span><br><span class="line">cv.imshow(&quot;face&quot;,face)</span><br><span class="line">cv.imshow(&quot;img_boradercv&quot;,img_boradercv)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-4边界反射-101"><a href="#4-5-4边界反射-101" class="headerlink" title="4.5.4边界反射_101"></a>4.5.4边界反射_101</h4><p>borderMode&#x3D;cv.BORDER_REFLECT101</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img_reflect101=cv.warpAffine(face,M,dsize=(img.shape[1],img.shape[0]),flags=cv.INTER_LINEAR,borderMode=cv.BORDER_REFLECT101)</span><br><span class="line">cv.imshow(&#x27;reflect&#x27;, img_reflect)</span><br><span class="line">cv.imshow(&quot;img&quot;,img)    </span><br><span class="line">cv.imshow(&quot;face&quot;,face)</span><br><span class="line">cv.imshow(&quot;img_boradercv&quot;,img_boradercv)</span><br><span class="line">cv.imshow(&quot;img_reflect101&quot;,img_reflect101)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5边缘常数填充"><a href="#4-5-5边缘常数填充" class="headerlink" title="4.5.5边缘常数填充"></a>4.5.5边缘常数填充</h4><p>borderMode&#x3D;cv.BORDER_CONSTANT,borderValue&#x3D;(0,0,255)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_ch=cv.warpAffine(face,M,(face.shape[1],face.shape[0]),cv.INTER_LANCZOS4,borderMode=cv.BORDER_CONSTANT,borderValue=(0,0,255))</span><br><span class="line">cv.imshow(&#x27;img_ch&#x27;,img_ch)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-6边缘包裹"><a href="#4-5-6边缘包裹" class="headerlink" title="4.5.6边缘包裹"></a>4.5.6边缘包裹</h4><p>borderMode&#x3D;cv.BORDER_WRAP</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_wrap=cv.warpAffine(face,M,(face.shape[<span class="number">1</span>],face.shape[<span class="number">0</span>]),cv.INTER_LANCZOS4,borderMode=cv.BORDER_WRAP)</span><br><span class="line">cv.imshow(<span class="string">&#x27;wrap&#x27;</span>,img_wrap)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-6图像矫正（透视变换）"><a href="#4-6图像矫正（透视变换）" class="headerlink" title="4.6图像矫正（透视变换）"></a>4.6图像矫正（透视变换）</h3><p>步骤：对原图需要矫正位置的坐标进行框中选定，输出图像的大小坐标分别创建两个numpy数组</p>
<p>使用cv.getPerspectiveTransform(pic1,pic_2)创建仿射变换矩阵M</p>
<p>使用cv.warpPerspective(img_tou,M,(w,h),flags&#x3D;cv.INTER_LINEAR,borderMode&#x3D;cv.BORDER_CONSTANT)</p>
<p>cv.warpPerspective(参数：图像片，变换矩阵，输出尺寸，插值方法，边界填充方式)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">pic1=np.float32([[182,113],[521,141],[115,294],[501,340]])</span><br><span class="line">print(pic1[0].shape)</span><br><span class="line"></span><br><span class="line">M = cv.getPerspectiveTransform(pic1,pic_2)</span><br><span class="line">new_img=new_pic = cv.warpPerspective(img_tou,M,(w,h),flags=cv.INTER_LINEAR,borderMode=cv.BORDER_CONSTANT)#参数：图像片，变换矩阵，输出尺寸，插值方法，边界填充方式</span><br><span class="line">cv.imshow(&#x27;new_img&#x27;,new_img)</span><br><span class="line">cv.imshow(&#x27;img_tou&#x27;,img_tou)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-7图像叠加"><a href="#4-7图像叠加" class="headerlink" title="4.7图像叠加"></a>4.7图像叠加</h3><h4 id="4-7-1直接相加"><a href="#4-7-1直接相加" class="headerlink" title="4.7.1直接相加"></a>4.7.1直接相加</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pig=cv.imread(&#x27;./images/pig.png&#x27;)</span><br><span class="line">cao=cv.imread(&#x27;./images/cao.png&#x27;)</span><br><span class="line">img_numpy=cao+pig</span><br><span class="line">print(img_numpy)</span><br></pre></td></tr></table></figure>

<h4 id="4-7-2add函数饱和运算"><a href="#4-7-2add函数饱和运算" class="headerlink" title="4.7.2add函数饱和运算"></a>4.7.2add函数饱和运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img_add=cv.add(pig,cao)</span><br><span class="line">print(cv.add(pig,cao))#add函数</span><br></pre></td></tr></table></figure>

<h4 id="4-7-3加权求和运算"><a href="#4-7-3加权求和运算" class="headerlink" title="4.7.3加权求和运算"></a>4.7.3加权求和运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_weight=cv.addWeighted(pig,0.5,cao,0.5,0)#加权求和运算·</span><br></pre></td></tr></table></figure>

<h3 id="4-8图像处理转换"><a href="#4-8图像处理转换" class="headerlink" title="4.8图像处理转换"></a>4.8图像处理转换</h3><p>函数cv.cvtcolor(参数：转换方式)</p>
<h4 id="4-8-1rgb转换为gray"><a href="#4-8-1rgb转换为gray" class="headerlink" title="4.8.1rgb转换为gray"></a>4.8.1rgb转换为gray</h4><p>cat_grey&#x3D;cv.cvtColor(cat,cv.COLOR_RGB2GRAY)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">cat=cv.imread(&#x27;./images/cat1.png&#x27;)</span><br><span class="line">cv.imshow(&#x27;cat&#x27;,cat)</span><br><span class="line">cat_grey=cv.cvtColor(cat,cv.COLOR_RGB2GRAY)</span><br><span class="line">cv.imshow(&#x27;cat_grey&#x27;,cat_grey)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-8-2rgb转换为hsv"><a href="#4-8-2rgb转换为hsv" class="headerlink" title="4.8.2rgb转换为hsv"></a>4.8.2rgb转换为hsv</h4><p>cat_hsv&#x3D;cv.cvtColor(cat,cv.COLOR_BGR2HSV)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat_hsv=cv.cvtColor(cat,cv.COLOR_BGR2HSV)</span><br><span class="line">cv.imshow(&quot;cat_hsv&quot;,cat_hsv)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-9灰度实验"><a href="#4-9灰度实验" class="headerlink" title="4.9灰度实验"></a>4.9灰度实验</h3><h4 id="4-9-1最大值灰度转换"><a href="#4-9-1最大值灰度转换" class="headerlink" title="4.9.1最大值灰度转换"></a>4.9.1最大值灰度转换</h4><p>使用for循环迭代，取颜色通道中的最大值，并且赋值到颜色通道上去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">pig_y=cv.imread(&#x27;./images/pig.png&#x27;)</span><br><span class="line">pig=cv.imread(&#x27;./images/pig.png&#x27;)</span><br><span class="line">for i in range(pig.shape[0]):</span><br><span class="line">    for j in range(pig.shape[1]):</span><br><span class="line">        pig[i][j][0]=max(pig[i][j])</span><br><span class="line">        pig[i][j][1]=max(pig[i][j])</span><br><span class="line">        pig[i][j][2]=max(pig[i][j])</span><br><span class="line">cv.imshow(&#x27;pig&#x27;,pig)</span><br><span class="line">cv.imshow(&#x27;pig_y&#x27;,pig_y)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-9-2平均值灰度"><a href="#4-9-2平均值灰度" class="headerlink" title="4.9.2平均值灰度"></a>4.9.2平均值灰度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">pig = cv.imread(&quot;./images/pig.png&quot;)</span><br><span class="line">h,w,_ = pig.shape</span><br><span class="line">av_grey=np.zeros((h,w),dtype=np.uint8)#uint8:0~255</span><br><span class="line">for i in range(h):</span><br><span class="line">    for j in range(w):</span><br><span class="line">        av_grey[i,j] = int(sum((pig[i,j])))//3</span><br><span class="line">cv.imshow(&quot;av&quot;,av_grey)</span><br><span class="line">cv.imshow(&quot;pig&quot;,pig)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-9-3加权灰度"><a href="#4-9-3加权灰度" class="headerlink" title="4.9.3加权灰度"></a>4.9.3加权灰度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wr,wg,wb=0.299,0.576,0.114</span><br><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">pig = cv.imread(&quot;./images/pig.png&quot;)</span><br><span class="line">h,w,_ = pig.shape</span><br><span class="line">weight_grey=np.zeros((h,w),dtype=np.uint8)#uint8:0~255</span><br><span class="line">for i in range(h):</span><br><span class="line">    for j in range(w):</span><br><span class="line">        weight_grey[i,j] = np.array([pig[i,j,0]*wr,pig[i,j,1]*wg,pig[i,j,2]*wb]).sum()/3</span><br><span class="line">cv.imshow(&quot;av&quot;,weight_grey)</span><br><span class="line">cv.imshow(&quot;pig&quot;,pig)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-10图像二值化处理"><a href="#4-10图像二值化处理" class="headerlink" title="4.10图像二值化处理"></a>4.10图像二值化处理</h3><p><em><strong>cv.threshold(图片，阈值，maxval，方法)</strong></em></p>
<h4 id="4-10-1阈值法-cv-THRESH-BINARY"><a href="#4-10-1阈值法-cv-THRESH-BINARY" class="headerlink" title="4.10.1阈值法(cv.THRESH_BINARY)"></a>4.10.1阈值法(cv.THRESH_BINARY)</h4><p>小于等于阈值的像素就被设置为0（通常代表背景），大于阈值的像素就被设置为maxval（通常代表前景）</p>
<h4 id="4-10-2反阈值法-THRESH-BINARY-INV"><a href="#4-10-2反阈值法-THRESH-BINARY-INV" class="headerlink" title="4.10.2反阈值法(THRESH_BINARY_INV)"></a>4.10.2反阈值法(THRESH_BINARY_INV)</h4><p>像素值大于阈值时，该像素值将会变成0（黑），当灰度图的像素值小于等于阈值时，该像素值将会变成maxval</p>
<h4 id="4-10-3截断阈值法-THRESH-TRUNC"><a href="#4-10-3截断阈值法-THRESH-TRUNC" class="headerlink" title="4.10.3截断阈值法(THRESH_TRUNC)"></a>4.10.3截断阈值法(THRESH_TRUNC)</h4><p>像素值大于阈值的部分将会被修改为阈值，小于等于阈值的部分不变。</p>
<h4 id="4-10-4低阈值零处理-THRESH-TOZERO"><a href="#4-10-4低阈值零处理-THRESH-TOZERO" class="headerlink" title="4.10.4低阈值零处理(THRESH_TOZERO)"></a>4.10.4低阈值零处理(THRESH_TOZERO)</h4><p>像素值小于等于阈值的部分被置为0（也就是黑色），大于阈值的部分不变。</p>
<h4 id="4-10-5超阈值零处理-THRESH-TOZERO-INV"><a href="#4-10-5超阈值零处理-THRESH-TOZERO-INV" class="headerlink" title="4.10.5超阈值零处理(THRESH_TOZERO_INV)"></a>4.10.5超阈值零处理(THRESH_TOZERO_INV)</h4><p>像素值大于阈值的部分置为0（也就是黑色），像素值小于等于阈值的部分不变。</p>
<h4 id="4-10-6OSTU阈值法-THRESH-OTSU"><a href="#4-10-6OSTU阈值法-THRESH-OTSU" class="headerlink" title="4.10.6OSTU阈值法(THRESH_OTSU)"></a>4.10.6OSTU阈值法(THRESH_OTSU)</h4><p>采取最大类间距的策略，该方法是使用是寻找最佳阈值</p>
<h4 id="4-10-7自适应二值法"><a href="#4-10-7自适应二值法" class="headerlink" title="4.10.7自适应二值法"></a>4.10.7自适应二值法</h4><p><em><strong>cv.adaptiveThreshold(参数1：灰度图，参数2：最大值，参数3：自适应阈值方法，参数4：二值化方法，参数5：窗口大小，参数6：偏移量)</strong></em></p>
<p>明暗分布不均匀可以使用自适应二值化</p>
<h5 id="4-10-7-1均值法-ADAPTIVE-THRESH-MEAN-C"><a href="#4-10-7-1均值法-ADAPTIVE-THRESH-MEAN-C" class="headerlink" title="4.10.7.1均值法(ADAPTIVE_THRESH_MEAN_C)"></a>4.10.7.1均值法(ADAPTIVE_THRESH_MEAN_C)</h5><p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_mean=cv.adaptiveThreshold(gray,255,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,5,10)</span><br><span class="line">cv.imshow(&#x27;mean&#x27;,img_mean)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-10-7-2加权求和法-ADAPTIVE-THRESH-GAUSSIAN-C"><a href="#4-10-7-2加权求和法-ADAPTIVE-THRESH-GAUSSIAN-C" class="headerlink" title="4.10.7.2加权求和法(ADAPTIVE_THRESH_GAUSSIAN_C)"></a>4.10.7.2加权求和法(ADAPTIVE_THRESH_GAUSSIAN_C)</h5><p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_guss=cv.adaptiveThreshold(gray,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,11,2)</span><br><span class="line">cv.imshow(&#x27;img_guss&#x27;,img_guss)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-11制作图像掩膜"><a href="#4-11制作图像掩膜" class="headerlink" title="4.11制作图像掩膜"></a>4.11制作图像掩膜</h3><h4 id="4-11-1制作掩膜及其修改颜色步骤"><a href="#4-11-1制作掩膜及其修改颜色步骤" class="headerlink" title="4.11.1制作掩膜及其修改颜色步骤"></a>4.11.1制作掩膜及其修改颜色步骤</h4><ul>
<li><p>图像掩膜是图像处理中的一个重要概念，它用于对图像进行遮罩，从而实现对图像的裁剪、过滤、增强等操作。</p>
</li>
<li><p>设置：color_low&#x3D;np.array([23,46,46])   color_high&#x3D;np.array([34,255,255])</p>
</li>
<li><p>根据hsv表创建掩膜，最大值和最小值，掩膜输出的是目标区域显示为白色，其他为黑色</p>
</li>
<li><p>参数：src：源图像，lowerb：颜色下限，upperb：颜色上限，dst：输出图像</p>
</li>
<li><p>做与运算输出，输出结果将目标白色替换为原色，其他不变</p>
</li>
</ul>
<p>颜色bgr转hsv </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">demo=cv.imread(&quot;./images/demo.png&quot;)</span><br><span class="line">demo=cv.resize(demo,(480,480))</span><br><span class="line">#颜色bgr转hsv</span><br><span class="line">demo_hsv=cv.cvtColor(demo,cv.COLOR_BGR2HSV)</span><br></pre></td></tr></table></figure>

<p>创建掩膜：cv.inRange(src,lowerb,upperb,dst) </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#创建掩膜：cv.inRange(src,lowerb,upperb,dst)，参数：src：源图像，lowerb：颜色下限，upperb：颜色上限，dst：输出图像</span><br><span class="line">color_low=np.array([23,46,46])</span><br><span class="line">color_high=np.array([34,255,255])</span><br></pre></td></tr></table></figure>

<p>做与运算输出掩膜cv.bitwise_and(demo,demo,mask&#x3D;mask)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#创建掩膜与原图大小一样，是一个二值化图像</span><br><span class="line">mask=cv.inRange(demo_hsv,color_low,color_high)#只显示黑白色</span><br><span class="line">mask_and=cv.bitwise_and(demo,demo,mask=mask)#做两次运算前两个颜色，再与掩膜运算</span><br></pre></td></tr></table></figure>

<p>将原图目标色进行替换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#修改颜色</span><br><span class="line">demo[mask==255]=[0,255,0]</span><br><span class="line">cv.imshow(&#x27;demo&#x27;,demo)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-11-2掩膜实例–添加水印"><a href="#4-11-2掩膜实例–添加水印" class="headerlink" title="4.11.2掩膜实例–添加水印"></a>4.11.2掩膜实例–添加水印</h4><h5 id="4-11-2-1ROI切割"><a href="#4-11-2-1ROI切割" class="headerlink" title="4.11.2.1ROI切割"></a>4.11.2.1ROI切割</h5><p>也就是使用numpy数组进行切割，不作赘述</p>
<h5 id="4-11-2-2添加水印实例"><a href="#4-11-2-2添加水印实例" class="headerlink" title="4.11.2.2添加水印实例"></a>4.11.2.2添加水印实例</h5><p>步骤：</p>
<p>从原图切下需要添加水印的区域，并进行灰度处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">logo=cv.imread(&#x27;images/logohq.png&#x27;)</span><br><span class="line">bg=cv.imread(&#x27;images/bg.png&#x27;)</span><br><span class="line">h,w=logo.shape[:2]</span><br><span class="line">logo_grey=cv.cvtColor(logo,cv.COLOR_BGR2GRAY)</span><br><span class="line">bg_zi=bg[:h,:w]</span><br></pre></td></tr></table></figure>

<p>分别将logo图进行二值化，分别使用阈值法和反阈值法进行变换</p>
<p>阈值法白底黑字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_,logo_grey_black=cv.threshold(logo_grey,170,255,cv.THRESH_BINARY)</span><br></pre></td></tr></table></figure>

<p>反阈值法白字黑底</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_,logo_grey_binary=cv.threshold(logo_grey,170,255,cv.THRESH_BINARY_INV)</span><br></pre></td></tr></table></figure>

<p>分别将两个所得图原logo图和截取区域进行与运算</p>
<p>将白字替换为原来的颜色，制作掩膜</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logo_and=cv.bitwise_and(logo,logo,mask=logo_grey_binary)#掩膜</span><br></pre></td></tr></table></figure>

<p>将另一张图的黑字与截取区域作与运算，得到一个黑字logo和原背景图结合的图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logo_and_black=cv.bitwise_and(bg_zi,bg_zi,mask=logo_grey_black)</span><br></pre></td></tr></table></figure>

<p>对所得掩膜进行add运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg_zi[:]=cv.add(logo_and,logo_and_black)</span><br></pre></td></tr></table></figure>

<h3 id="4-12噪点消除"><a href="#4-12噪点消除" class="headerlink" title="4.12噪点消除"></a>4.12噪点消除</h3><h5 id="4-12-1均值滤波"><a href="#4-12-1均值滤波" class="headerlink" title="4.12.1均值滤波"></a>4.12.1均值滤波</h5><p>cv.blur(img,(3,3))</p>
<ul>
<li>参数：目标图，核尺寸（只能为单数）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">#均值滤波cv.blur</span><br><span class="line">img=cv.imread(&quot;./images/lvbo2.png&quot;)</span><br><span class="line">img_blur=cv.blur(img,(3,3))#均值滤波</span><br><span class="line">cv.imshow(&quot;img&quot;,img)</span><br><span class="line">cv.imshow(&quot;img_blur&quot;,img_blur)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-12-2方框滤波"><a href="#4-12-2方框滤波" class="headerlink" title="4.12.2方框滤波"></a>4.12.2方框滤波</h5><p>cv.boxFilter(img, -1, (3,3),normalize&#x3D;True、False)</p>
<ul>
<li>参数：输入图像，输出图像的深度，核大小，是否归一化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#方框滤波cv.boxFilter</span><br><span class="line">img_box=cv.boxFilter(img, -1, (3,3),normalize=True)#参数：输入图像，输出图像的深度，核大小，是否归一化</span><br><span class="line">img_box_F=cv.boxFilter(img, -1, (3,3),normalize=False)</span><br><span class="line">cv.imshow(&#x27;img_box&#x27;,img_box)</span><br><span class="line">cv.imshow(&#x27;img_box_F&#x27;,img_box_F)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-12-3高斯滤波"><a href="#4-12-3高斯滤波" class="headerlink" title="4.12.3高斯滤波"></a>4.12.3高斯滤波</h5><p>cv.GaussianBlur(img,(3,3),1)</p>
<ul>
<li>参数：1、原图；2、核大小；3、标准差</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#高斯滤波:好用cv.GaussianBlur</span><br><span class="line">img_gauss=cv.GaussianBlur(img,(3,3),1)#参数：1、原图；2、核大小；3、标准差</span><br><span class="line">cv.imshow(&#x27;img_gauss&#x27;,img_gauss)</span><br><span class="line">cv.imshow(&quot;img&quot;,img)</span><br><span class="line">cv.imshow(&quot;img_blur&quot;,img_blur)    </span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-12-4中值滤波"><a href="#4-12-4中值滤波" class="headerlink" title="4.12.4中值滤波"></a>4.12.4中值滤波</h5><p>cv.medianBlur(img_jy, 5)</p>
<ul>
<li>更适合椒盐噪声</li>
<li>参数1.原图，2.核大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img_jy=cv.imread(&quot;images/lvbo3.png&quot;)#更适合椒盐噪声</span><br><span class="line">#中值滤波：cv.medianBlur</span><br><span class="line">img_median = cv.medianBlur(img_jy, 5)#参数1.原图，2.核大小</span><br><span class="line">cv.imshow(&quot;median&quot;, img_median)</span><br><span class="line">cv.imshow(&quot;jy&quot;, img_jy)</span><br><span class="line">cv.waitKey(0)   </span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-12-5双边滤波"><a href="#4-12-5双边滤波" class="headerlink" title="4.12.5双边滤波"></a>4.12.5双边滤波</h5><p>cv.bilateralFilter(img,9,75,75)</p>
<ul>
<li>参数：图片，区域大小，高斯核，高斯核</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_doubleb=cv.bilateralFilter(img,9,75,75)#参数：图片，区域大小，高斯核，高斯核</span><br><span class="line">cv.imshow(&#x27;img_doubleb&#x27;,img_doubleb)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-13图像梯度处理"><a href="#4-13图像梯度处理" class="headerlink" title="4.13图像梯度处理"></a>4.13图像梯度处理</h3><p>滤波是应用卷积来实现的，卷积的关键就是卷积核，我们来考察下面这个卷积核：<br>$$<br>k1&#x3D;\left[\begin{array}{c c c}1&amp;0&amp;1\2&amp;0&amp;2\1&amp;0&amp;1\end{array}\right]<br>$$</p>
<h4 id="4-13-1sobel算子"><a href="#4-13-1sobel算子" class="headerlink" title="4.13.1sobel算子"></a>4.13.1sobel算子</h4><p>cv.Sobel(img,-1,1,1,3)，会进行边缘反射_101，再进行计算</p>
<p>参数：图像，深度，横向，纵向，核大小</p>
<p>横向可以设置1或者0，为1则绘制横向边缘</p>
<p>纵向同理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">img_sobel=cv.Sobel(img,-1,1,1,3)</span><br><span class="line">img_sobel_x=cv.Sobel(img,-1,1,0,3)#求纵向边缘</span><br><span class="line">img_sobel_y=cv.Sobel(img,-1,0,1,3)#求横向边缘</span><br><span class="line">cv.imshow(&quot;sobel&quot;,img_sobel)</span><br><span class="line">cv.imshow(&quot;sobel_x&quot;,img_sobel_x)</span><br><span class="line">cv.imshow(&quot;sobel_y&quot;,img_sobel_y)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-13-2Laplacian算子"><a href="#4-13-2Laplacian算子" class="headerlink" title="4.13.2Laplacian算子"></a>4.13.2Laplacian算子</h4><p>cv.Laplacian(img,-1)</p>
<p>参数：输入图像，输出图像的深度，核大小，偏移量，核类型（以上示例只填写了前两个）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 模拟一张图像，灰度图</span><br><span class="line">img=np.array([[100,102,109,110,98,20,19,18,21,22],</span><br><span class="line">             [109,101,98,108,102,20,21,19,20,21],</span><br><span class="line">             [109,102,105,108,98,20,22,19,19,18],</span><br><span class="line">             [109,98,102,108,102,20,23,19,20,22],</span><br><span class="line">             [109,102,105,108,98,20,22,19,20,18],</span><br><span class="line">             [100,102,108,110,98,20,19,18,21,22],</span><br><span class="line">             [109,101,98,108,102,20,22,19,20,21],</span><br><span class="line">             [109,102,108,108,98,20,22,19,19,18],</span><br><span class="line">              ],dtype=np.float32)</span><br><span class="line">img_la=cv.Laplacian(img,-1)#参数：输入图像，输出图像的深度，核大小，偏移量，核类型</span><br><span class="line">print(img)</span><br><span class="line">cv.imshow(&#x27;laplacian&#x27;,img_la)</span><br><span class="line">print(img_la)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[ 22.   3. -28. -17. -58.  77.   4.   6.  -4.  -4.]</span><br><span class="line"> [-25.   7.  31. -14. -84.  83.  -4.   2.   0.  -4.]</span><br><span class="line"> [-14.   5. -10. -13. -60.  80.  -5.   3.   1.   9.]</span><br><span class="line"> [-22.  23.   8. -12. -84.  85.  -9.   5.   0. -12.]</span><br><span class="line"> [-23.   6.   0. -11. -64.  80.  -7.   3.  -2.  12.]</span><br><span class="line"> [ 22.   3. -17. -18. -62.  77.   6.   6.  -4.  -7.]</span><br><span class="line"> [-25.   7.  33. -14. -84.  84.  -8.   3.   0.  -4.]</span><br><span class="line"> [-14.  11. -26. -10. -60.  80.  -5.   3.   1.   8.]]</span><br></pre></td></tr></table></figure>

<h3 id="4-14边缘检测"><a href="#4-14边缘检测" class="headerlink" title="4.14边缘检测"></a>4.14边缘检测</h3><p>不是一个算子，是完整的一整套方案。</p>
<h4 id="4-14-1-高斯滤波"><a href="#4-14-1-高斯滤波" class="headerlink" title="4.14.1 高斯滤波"></a>4.14.1 高斯滤波</h4><p>就是去除噪点！</p>
<p>边缘检测本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理。这里使用的是一个5*5的高斯核对图像进行消除噪声。上一个实验中已经介绍了高斯滤波的具体过程，这里就不再过多叙述，只展示一下用到的5*5的高斯核：</p>
<h4 id="4-14-2-计算图像的梯度与方向"><a href="#4-14-2-计算图像的梯度与方向" class="headerlink" title="4.14.2 计算图像的梯度与方向"></a>4.14.2 计算图像的梯度与方向</h4><p>这里使用了sobel算子来计算图像的梯度值，在上一章节中，我们了解到sobel算子其实就是一个核值固定的卷积核，如下所示：<br>$$<br>sobel(水平方向)&#x3D;\left[\begin{array}{c c c}1&amp;0&amp;1\2&amp;0&amp;2\1&amp;0&amp;1\end{array}\right]<br>$$</p>
<p>$$<br>sobel(垂直方向)&#x3D;\left[\begin{array}{c c c}1&amp;2&amp;1\ 0&amp;0&amp;0\ 1&amp;2&amp;1\end{array}\right]<br>$$</p>
<p>首先使用sobel算子计算中心像素点的两个方向上的梯度$G_{x}$和$G_{y}$，然后就能够得到其具体的梯度值：<br>$$<br>G&#x3D;{\sqrt{G_{x}{}^{2}+G_{y}{}^{2}}}<br>$$<br>也可以使用$G&#x3D;|G_{x}+G_{y}|$来代替。在OpenCV中，默认使用$G&#x3D;|G_{x}+G_{y}|$来计算梯度值。</p>
<p>然后我们根据如下公式可以得到一个角度值</p>
<p>​																						$${\frac{G_{\mathrm{y}}}{G_{x}}}&#x3D;\tan,(\theta)$$<br>$$<br>\theta&#x3D;\arctan,({\frac{G_{\mathrm{y}}}{G_{x}}})<br>$$<br><strong>这个角度值其实是当前边缘的梯度的方向</strong>。通过这个公式我们就可以计算出图片中所有的像素点的梯度值与梯度方向，然后根据梯度方向获取边缘的方向。</p>
<p>a). 并且如果梯度方向不是0°、45°、90°、135°这种特定角度，那么就要用到插值算法来计算当前像素点在其方向上进行插值的结果了，然后进行比较并判断是否保留该像素点。这里使用的是单线性插值，通过A1和A2两个像素点获得dTmp1与dTmp2处的插值，然后与中心点C进行比较(非极大值抑制)。具体的插值算法请参考图像旋转实验。</p>
<p>b). 得到$\theta$的值之后，就可以对边缘方向进行分类，为了简化计算过程,一般将其归为四个方向：水平方向、垂直方向、45°方向、135°方向。并且：</p>
<p>当$\theta$值为-22.5°~22.5°，或-157.5°~157.5°，则认为边缘为水平边缘；</p>
<p>当法线方向为22.5°~67.5°，或-112.5°~-157.5°，则认为边缘为45°边缘；</p>
<p>当法线方向为67.5°~112.5°，或-67.5°~-112.5°，则认为边缘为垂直边缘；</p>
<p>当法线方向为112.5°~157.5°，或-22.5°~-67.5°，则认为边缘为135°边缘；</p>
<h4 id="4-14-3-非极大值抑制"><a href="#4-14-3-非极大值抑制" class="headerlink" title="4.14.3 非极大值抑制"></a>4.14.3 非极大值抑制</h4><p>得到每个边缘的方向之后，其实把它们连起来边缘检测就算完了，但是为什么还有这一步与下一步呢？是因为经过第二步得到的边缘不经过处理是没办法使用的，因为高斯滤波的原因，边缘会变得模糊，导致经过第二步后得到的边缘像素点非常多，因此我们需要对其进行一些过滤操作，而非极大值抑制就是一个很好的方法，它会对得到的边缘像素进行一个排除，使边缘尽可能细一点。</p>
<p>在该步骤中，我们需要检查每个像素点的梯度方向上的相邻像素，并保留梯度值最大的像素，将其他像素抑制为零。假设当前像素点为（x，y），其梯度方向是0°，梯度值为G（x，y），那么我们就需要比较G（x，y）与两个相邻像素的梯度值：G（x-1，y）和G（x+1，y）。如果G（x，y）是三个值里面最大的，就保留该像素值，否则将其抑制为零。</p>
<h4 id="4-14-4代码用法"><a href="#4-14-4代码用法" class="headerlink" title="4.14.4代码用法"></a>4.14.4代码用法</h4><p>cv2.Canny(image, threshold1, threshold2)，</p>
<p>参数：图像，阈值1，阈值2</p>
<p>即使读到的是彩色图也可以进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#边缘检测</span><br><span class="line">img=cv.imread(&#x27;images/lvbo2.png&#x27;)</span><br><span class="line">ret,img_binary=cv.threshold(img,127,255,cv.THRESH_BINARY)</span><br><span class="line">img_ga=cv.GaussianBlur(img,(3,3),1)#作用：高斯模糊，作用：降噪</span><br><span class="line">ret,img_ga_binary=cv.threshold(img_ga,127,255,cv.THRESH_BINARY)</span><br><span class="line">dst_img=cv.Canny(img_binary,30,70)#参数：二值化后的图像，阈值1，阈值2</span><br><span class="line">dst_img_gau=cv.Canny(img_ga_binary,30,70)</span><br><span class="line">cv.imshow(&#x27;dst_img_gau&#x27;,dst_img_gau)</span><br><span class="line">cv.imshow(&#x27;dst_img&#x27;,dst_img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>



<h3 id="4-15绘制图像轮廓"><a href="#4-15绘制图像轮廓" class="headerlink" title="4.15绘制图像轮廓"></a>4.15绘制图像轮廓</h3><h4 id="4-15-1轮廓的定义"><a href="#4-15-1轮廓的定义" class="headerlink" title="4.15.1轮廓的定义"></a>4.15.1轮廓的定义</h4><p>- 轮廓是一系列连续的点和组成的曲线，代表了物体的基本外形。是一个闭合和封闭的图形</p>
<h4 id="4-15-2操作步骤"><a href="#4-15-2操作步骤" class="headerlink" title="4.15.2操作步骤"></a>4.15.2操作步骤</h4><p>1、先对图像进行预处理</p>
<p>转灰度，二值化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#绘制轮廓步骤，RETR_EXTERNAL 只绘制最外轮廓 存储中：CHAIN_APPROX_SIMPLE</span><br><span class="line">num_y=cv.imread(&quot;../images/num.png&quot;)</span><br><span class="line">#读图转灰度</span><br><span class="line">number=cv.imread(&quot;../images/num.png&quot;,cv.IMREAD_GRAYSCALE)</span><br><span class="line">#二值化</span><br><span class="line">_,num_t=cv.threshold(number,127,255,cv.THRESH_OTSU+cv.THRESH_BINARY_INV)</span><br></pre></td></tr></table></figure>

<p>2、关键操作：调用cv.findContours(目标图，找轮廓点的种类，保存方法）会返回两个值：轮廓坐标集合和层级结构</p>
<ul>
<li>常用的种类</li>
</ul>
<ol>
<li><strong>RETR_EXTERNAL</strong></li>
</ol>
<p>表示只查找最外层的轮廓。并且在hierarchy里的轮廓关系中，每一个轮廓只有前一条轮廓与后一条轮廓的索引，而没有父轮廓与子轮廓的索引。</p>
<p>2.3.4.会查找所有轮廓，但会有层级关系。</p>
<ol start="2">
<li><strong>RETR_LIST</strong></li>
</ol>
<p>表示列出所有的轮廓。并且在hierarchy里的轮廓关系中，每一个轮廓只有前一条轮廓与后一条轮廓的索引，而没有父轮廓与子轮廓的索引。</p>
<ol start="3">
<li><strong>RETR_CCOMP</strong></li>
</ol>
<p>表示列出所有的轮廓。并且在hierarchy里的轮廓关系中，轮廓会按照成对的方式显示。</p>
<p>在 <code>RETR_CCOMP</code> 模式下，轮廓被分为两个层级：</p>
<ul>
<li><strong>层级 0</strong>：所有外部轮廓（最外层的边界）。</li>
<li><strong>层级 1</strong>：所有内部轮廓（孔洞或嵌套的区域）。</li>
</ul>
<ol start="4">
<li><strong>RETR_TREE</strong></li>
</ol>
<p>表示列出所有的轮廓。并且在hierarchy里的轮廓关系中，轮廓会按照树的方式显示，其中最外层的轮廓作为树根，其子轮廓是一个个的树枝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查找轮廓</span><br><span class="line">contours,h=cv.findContours(num_t,mode=cv.RETR_EXTERNAL,method=cv.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure>

<p>绘制轮廓</p>
<p>使用cv.drawContours()将要绘制在什么图上，深度，所得的轮廓坐标列表，颜色，绘制线宽度依次传入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num=cv.drawContours(num_y,contours,-1,(0,0,255),2)</span><br></pre></td></tr></table></figure>

<p>显示图像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv.imshow(&quot;num_t&quot;,num_t)  </span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-16绘制凸包"><a href="#4-16绘制凸包" class="headerlink" title="4.16绘制凸包"></a>4.16绘制凸包</h3><h4 id="4-16-1定义和方法"><a href="#4-16-1定义和方法" class="headerlink" title="4.16.1定义和方法"></a>4.16.1定义和方法</h4><p>在进行凸包特征检测之前，首先要了解什么是凸包。通俗的讲，凸包其实就是将一张图片中物体的最外层的点连接起来构成的凸多边形，它能包含物体中所有的内容。</p>
<p>一般来说，凸包都是伴随着某类点集存在的，也被称为某个点集的凸包。</p>
<p>对于一个点集来说，如果该点集存在凸包，那么这个点集里面的所有点要么在凸包上，要么在凸包内。</p>
<p>凸包检测常用在物体识别、手势识别、边界检测等领域。穷举法时间复杂度高不特殊情况不采用</p>
<ul>
<li>穷举法</li>
<li>QuickHull法</li>
</ul>
<h4 id="4-16-2quickhull法的代码实现步骤"><a href="#4-16-2quickhull法的代码实现步骤" class="headerlink" title="4.16.2quickhull法的代码实现步骤"></a>4.16.2quickhull法的代码实现步骤</h4><p>预处理灰度和二值化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#读图</span><br><span class="line">img=cv.imread(&#x27;../images/tu.png&#x27;)</span><br><span class="line"></span><br><span class="line">#转灰度</span><br><span class="line">img_g=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">#二值化</span><br><span class="line">ret,img_b=cv.threshold(img_g,127,255,cv.THRESH_BINARY)</span><br></pre></td></tr></table></figure>

<p>查找轮廓</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查找轮廓</span><br><span class="line">ct,h=cv.findContours(img_b,cv.RETR_TREE,cv.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure>

<p>将凸包找出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#寻找凸包</span><br><span class="line">hull=cv.convexHull(ct[0])</span><br><span class="line">print(hull)</span><br></pre></td></tr></table></figure>

<p>绘制凸包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#绘制凸包</span><br><span class="line">cv.polylines(img,[hull],True,(0,255,0),1,cv.LINE_AA)</span><br><span class="line">#显示图像</span><br><span class="line">cv.imshow(&#x27;img&#x27;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-17绘制矩形"><a href="#4-17绘制矩形" class="headerlink" title="4.17绘制矩形"></a>4.17绘制矩形</h3><h4 id="4-17-1绘制正向的一般矩形"><a href="#4-17-1绘制正向的一般矩形" class="headerlink" title="4.17.1绘制正向的一般矩形"></a>4.17.1绘制正向的一般矩形</h4><p>读图、图像预处理、灰度、二值化</p>
<p>白色图像为目标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#绘制矩形</span><br><span class="line">import  cv2 as cv</span><br><span class="line">img=cv.imread(&#x27;../images/num.png&#x27;)</span><br><span class="line">num=img.copy()</span><br><span class="line">num_gray=cv.cvtColor(num,cv.COLOR_BGR2GRAY)</span><br><span class="line">_,num_binary=cv.threshold(num_gray,150,255,cv.THRESH_BINARY_INV)#反阈值法</span><br></pre></td></tr></table></figure>

<p>找到轮廓，并且绘制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c,h=cv.findContours(num_binary,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line">img_Con=cv.drawContours(img,c,-1,(0,0,255),2)</span><br></pre></td></tr></table></figure>

<p>使用cv.boundingRect(cnt),找出矩形坐标，返回x,y和矩形的长和宽是</p>
<p>利用cv.rectangle绘制出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for cnt in c:</span><br><span class="line">    x,y,w,h=cv.boundingRect(cnt)</span><br><span class="line">    print(cnt,end=&#x27;,&#x27;)</span><br><span class="line">    cv.rectangle(img_Con,(x,y),(x+w,y+h),(0,255,0),1,cv.LINE_AA)</span><br><span class="line">cv.imshow(&#x27;drawing img_Con&#x27;,img_Con)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-17-2绘制最小矩阵"><a href="#4-17-2绘制最小矩阵" class="headerlink" title="4.17.2绘制最小矩阵"></a>4.17.2绘制最小矩阵</h4><p>无关方向，最小能包裹目标图像的矩形</p>
<p>读图、图像预处理、灰度、二值化</p>
<p>白色图像为目标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#绘制矩形</span><br><span class="line">import  cv2 as cv</span><br><span class="line">img=cv.imread(&#x27;../images/num.png&#x27;)</span><br><span class="line">num=img.copy()</span><br><span class="line">num_gray=cv.cvtColor(num,cv.COLOR_BGR2GRAY)</span><br><span class="line">_,num_binary=cv.threshold(num_gray,150,255,cv.THRESH_BINARY_INV)#反阈值法</span><br></pre></td></tr></table></figure>

<p>找到轮廓，并且绘制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c,h=cv.findContours(num_binary,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE)</span><br><span class="line">img_Con=cv.drawContours(img,c,-1,(0,0,255),2)</span><br></pre></td></tr></table></figure>

<p>使用cv.minAreaRect的方式已找到,cv.minAreaRect(),返回最小外接矩形的中心点、宽度和角度</p>
<p>利用cv.boxPoints(rect)将中心、尺寸和角度转换为四个角点坐标</p>
<p>并且转化为int类型</p>
<p>使用cv.polylines()绘制参数：目标图，坐标列表，是否闭合，颜色，宽度，线形</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for cnt in c:</span><br><span class="line">        # 计算最小外接矩形</span><br><span class="line">    rect = cv.minAreaRect(cnt)#返回最小外接矩形的中心点、宽高和角度</span><br><span class="line"></span><br><span class="line">    # 将最小外接矩形的中心、尺寸和角度转换为四个角点坐标</span><br><span class="line">    box = cv.boxPoints(rect)</span><br><span class="line">    box = box.astype(&#x27;int&#x27;)  # 转换为整数类型</span><br><span class="line">    </span><br><span class="line">    # 绘制旋转后的最小外接矩形</span><br><span class="line">    cv.polylines(img, [box], isClosed=True, color=(0, 0, 255), thickness=1, lineType=cv.LINE_AA)</span><br><span class="line">    </span><br><span class="line">    #绘制矩阵</span><br><span class="line">    x,y,w,h=cv.boundingRect(cnt)</span><br><span class="line">    cv.rectangle(img_Con,(x,y),(x+w,y+h),(255,0,0),2,cv.LINE_AA)</span><br><span class="line">    </span><br><span class="line">    #绘制凸包</span><br><span class="line">    hull = cv.convexHull(cnt)</span><br><span class="line">    # cv.drawContours(img_Con, [hull], 0, (0, 255, 0), 2, cv.LINE_AA)</span><br><span class="line">    cv.polylines(img_Con, [hull], isClosed=True, color=(0, 255, 0), thickness=2, lineType=cv.LINE_AA)</span><br></pre></td></tr></table></figure>

<h3 id="4-18直方图和直方图均衡化"><a href="#4-18直方图和直方图均衡化" class="headerlink" title="4.18直方图和直方图均衡化"></a>4.18直方图和直方图均衡化</h3><h4 id="4-18-1绘制直方图的步骤"><a href="#4-18-1绘制直方图的步骤" class="headerlink" title="4.18.1绘制直方图的步骤"></a>4.18.1绘制直方图的步骤</h4><p>读图</p>
<p>利用函数cv.calcHist([img],[2],None,[256],[0,256])</p>
<p>返回一个数组列表，代表每一个像素值的像素数量</p>
<p>参数：图片，通道，掩膜，直方图大小，直方图范围</p>
<ul>
<li>图片：目标图片</li>
<li>通道：指定通道</li>
<li>掩膜：可以对指定的白色区域进行绘制直方图，也可以为None</li>
<li>直方图大小：可以设定将像素值分为多少组进行统计</li>
<li>直方图范围：一般为[0,256]</li>
</ul>
<p>再使用cv.minMaxLoc提取最少数量像素值及其索引像素值和最多数量像素值及其索引像素值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">img=cv.imread(&#x27;../images/lvbo.png&#x27;)</span><br><span class="line">hist=cv.calcHist([img],[2],None,[256],[0,256])#计算直方图，参数：图片，通道，掩膜，直方图大小，直方图范围</span><br><span class="line">minVal,maxVal,minLoc,maxLoc=cv.minMaxLoc(hist) #返回值最少的像素个数，最多的像素个数，最小值位置索引，最大值位置索引</span><br></pre></td></tr></table></figure>

<p>可以使用matplotlib进行直线绘制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 绘制直方图</span><br><span class="line">plt.figure(figsize=(6, 4))</span><br><span class="line">plt.plot(hist, color=&#x27;r&#x27;)</span><br></pre></td></tr></table></figure>

<p>使用cv.line进行绘制直方图，将数据归一化，先限制直方图高度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr=np.zeros((256,256,3),np.uint8)</span><br><span class="line">#限制直方图的高</span><br><span class="line">hpt=int(0.9*256)</span><br><span class="line">#使用cv.line 画出直方图</span><br><span class="line">for i in range(256):</span><br><span class="line">    cv.line(arr,(i,256),(i,256-int(hist[i].item()*hpt/maxVal)),(0,0,255),2,1)</span><br><span class="line">cv.imshow(&#x27;hist&#x27;,arr)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>将绘制直方图的代码封装成函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def draw(img,m,color):</span><br><span class="line">    hist=cv.calcHist([img],[m],None,[256],[0,256])</span><br><span class="line">    minVal,maxVal,minLoc,maxLoc=cv.minMaxLoc(hist) #返回值最少的像素个数，最多的像素个数，最小值位置索引，最大值位置索引</span><br><span class="line">    arr=np.zeros((256,256,3),np.uint8)</span><br><span class="line">    #限制直方图的高</span><br><span class="line">    hpt=int(0.9*256)</span><br><span class="line">    #使用cv.line 画出直方图</span><br><span class="line">    for i in range(256):</span><br><span class="line">        cv.line(arr,(i,256),(i,256-int(hist[i].item()*hpt/maxVal)),color,2,1)</span><br><span class="line">    return arr</span><br><span class="line">img=cv.imread(&#x27;../images/lvbo.png&#x27;)</span><br><span class="line">cv.imshow(&quot;hist&quot;,draw(img,2,(0,0,255)))</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-18-2直方图均衡化"><a href="#4-18-2直方图均衡化" class="headerlink" title="4.18.2直方图均衡化"></a>4.18.2直方图均衡化</h4><p>同样的进行灰度化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#读图</span><br><span class="line">img=cv.imread(&#x27;../images/zhifang.png&#x27;)</span><br><span class="line">#转灰度图</span><br><span class="line">gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure>

<p>直方图均衡化使用cv.equalizeHist(gray)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eqh=cv.equalizeHist(gray)#直方图均衡化</span><br><span class="line">dst_eqh=draw(eqh,0,(0,255,0))</span><br><span class="line">cv.imshow(&#x27;eqh&#x27;,eqh)</span><br><span class="line">cv.imshow(&#x27;dst_eqh&#x27;,dst_eqh)</span><br></pre></td></tr></table></figure>

<p>对比度受限自适应直方图变化：</p>
<p><strong>clahe &#x3D; cv2.createCLAHE(clipLimit&#x3D;None, tileGridSize&#x3D;None)</strong></p>
<ul>
<li>clipLimit（可选）：对比度限制参数，用于控制直方图均衡化过程中对比度增强的程度。如果设置一个大于1的值（如2.0或4.0），CLAHE会限制对比度增强的最大程度，避免过度放大噪声。如果不设置，OpenCV会使用一个默认值。</li>
<li>tileGridSize（可选）：图像分块的大小，通常是一个包含两个整数的元组，如<code>(8, 8)</code>，表示将图像划分成8x8的小块进行独立的直方图均衡化处理。分块大小的选择会影响到CLAHE的效果以及处理速度。</li>
</ul>
<p>创建CLAHE对象后，可以使用 <code>.apply()</code> 方法对图像进行CLAHE处理：</p>
<p><strong>img&#x3D;clahe.apply(image)</strong></p>
<ul>
<li>image:要均衡化的图像。</li>
<li>img均衡后的图像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clahe=cv.createCLAHE(clipLimit=2.0,tileGridSize=(8,8))#对比度受限自适应直方图变化</span><br><span class="line">img_clahe=clahe.apply(gray)#意义：对比度受限</span><br><span class="line">cv.imshow(&#x27;img_clahe&#x27;,img_clahe)</span><br><span class="line">dst_clahe=draw(img_clahe,0,(0,255,0))</span><br><span class="line">cv.imshow(&#x27;dst_clahe&#x27;,dst_clahe)</span><br></pre></td></tr></table></figure>

<p>图像输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dst_gray=draw(gray,0,(0,0,255))</span><br><span class="line">cv.imshow(&#x27;img&#x27;,img)</span><br><span class="line">cv.imshow(&#x27;gray&#x27;,gray)</span><br><span class="line">cv.imshow(&#x27;dst_gray&#x27;,dst_gray)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-19模板匹配"><a href="#4-19模板匹配" class="headerlink" title="4.19模板匹配"></a>4.19模板匹配</h3><h4 id="4-19-1模版匹配步骤"><a href="#4-19-1模版匹配步骤" class="headerlink" title="4.19.1模版匹配步骤"></a>4.19.1模版匹配步骤</h4><p>进行匹配，读取原图和目标图并且进行转灰度图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">#读图</span><br><span class="line">img=cv.imread(&#x27;../images/game.png&#x27;)#目标图</span><br><span class="line">temp=cv.imread(&#x27;../images/temp.png&#x27;)#模板图</span><br><span class="line">#转灰度</span><br><span class="line">img_gray=cv.cvtColor(img,cv.COLOR_BGR2GRAY)#目标图转灰度</span><br><span class="line">temp_gray=cv.cvtColor(temp,cv.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure>

<p>使用cv.matchTemplate(原图，目标图，匹配的方法)</p>
<p>匹配方法，可以是以下之一：</p>
<ul>
<li>cv2.TM_CCOEFF</li>
<li>cv2.TM_CCOEFF_NORMED</li>
<li>cv2.TM_CCORR</li>
<li>cv2.TM_CCORR_NORMED</li>
<li>cv2.TM_SQDIFF</li>
<li>cv2.TM_SQDIFF_NORMED</li>
<li>这些方法决定了如何度量模板图像与原图像子窗口之间的相似度。</li>
</ul>
<p>返回值res</p>
<p>函数在完成图像模板匹配后返回一个结果矩阵，这个矩阵的大小与原图像相同。矩阵的每个元素表示原图像中相应位置与模板图像匹配的相似度。</p>
<p>设置阈值，使用np.where()的函数获取符合条件的坐标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threshold=0.8</span><br><span class="line">loc=np.where(res&gt;=threshold)</span><br><span class="line">h,w=temp.shape[:2]#获取目标图的长和宽</span><br></pre></td></tr></table></figure>

<p>使用zip(*loc)返回一个迭代器</p>
<p>进行图像绘制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for pt in zip(*loc):#py===&gt;(y,x)</span><br><span class="line">    leftupper=pt[::-1]#(x,y)</span><br><span class="line">    rightbottom=(pt[1]+w,pt[0]+h)#(x+w,y+h)</span><br><span class="line">    cv.rectangle(img,leftupper,rightbottom,(0,0,255),2)</span><br><span class="line">cv.imshow(&#x27;img&#x27;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-20霍夫变换"><a href="#4-20霍夫变换" class="headerlink" title="4.20霍夫变换"></a>4.20霍夫变换</h3><h4 id="4-20-1霍夫变换的基本理论"><a href="#4-20-1霍夫变换的基本理论" class="headerlink" title="4.20.1霍夫变换的基本理论"></a>4.20.1霍夫变换的基本理论</h4><p><strong>霍夫变换</strong>是图像处理的一种技术，主要用于检测图像中的直线、圆等几何形状。基本思想就是将图像空间中的点映射到<strong>参数空间</strong>中，通过在参数空间中寻找<strong>累计最大值</strong>实现对特定形状的检测。</p>
<h4 id="4-20-2霍夫变换的具体操作"><a href="#4-20-2霍夫变换的具体操作" class="headerlink" title="4.20.2霍夫变换的具体操作"></a>4.20.2霍夫变换的具体操作</h4><h5 id="4-20-2-1霍夫变换直线"><a href="#4-20-2-1霍夫变换直线" class="headerlink" title="4.20.2.1霍夫变换直线"></a>4.20.2.1霍夫变换直线</h5><p>cv.HoughLines(目标图像,r的精度,角度θ的精度,阈值)主要参数<br>目标图像：二值化，目标白，背景黑<br>r的精度：r的精度，以像素为单位，表示霍夫空间中每一步的距离增量, 值越大，考虑越多的线。<br>角度θ的精度：通常以弧度为单位，表示霍夫空间中每一步的角度增量。值越小，考虑越多的线。<br>阈值：满足目标斜率的函数图像上的点的最少数量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">img=cv.imread(&#x27;../images/huofu.png&#x27;)#读取图片</span><br><span class="line">img_g=cv.cvtColor(img,cv.COLOR_BGR2GRAY)#灰度化</span><br><span class="line">dst=cv.Canny(img_g,30,70)#获得边缘检测后的图像</span><br><span class="line">lines=cv.HoughLines(dst,0.9,np.pi/180,90)#进行霍夫直线变换</span><br><span class="line">#返回ro值和角度theta值</span><br><span class="line">print(lines)</span><br><span class="line">for line in lines:</span><br><span class="line">    ro = line[0][0]#提取ro</span><br><span class="line">    theta= line[0][1]#提取角度</span><br><span class="line">    sint_t=np.sin(theta)#计算cos和sin值</span><br><span class="line">    cost_t=np.cos(theta)</span><br><span class="line">    x1,x2=0,img.shape[1]#图的边界点</span><br><span class="line">    y1,y2=int((ro-x1*cost_t)/sint_t),int((ro-x2*cost_t)/sint_t)#将边界点带入计算</span><br><span class="line">    cv.line(img,(x1,y1),(x2,y2),(0,0,255),2)#绘制直线</span><br><span class="line">cv.imshow(&#x27;img&#x27;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-20-2-2统计概率霍夫直线变换"><a href="#4-20-2-2统计概率霍夫直线变换" class="headerlink" title="4.20.2.2统计概率霍夫直线变换"></a>4.20.2.2统计概率霍夫直线变换</h5><p>对于霍夫变换，对图像的预处理也尤其重要，若遇到明暗分布不均匀的图像，需要进行必要的处理<br>lines&#x3D;cv2.HoughLinesP(image, rho, theta, threshold, lines&#x3D;None, minLineLength&#x3D;0, maxLineGap&#x3D;0)**</p>
<p>image：输入图像，通常为二值图像，其中白点表示边缘点，黑点为背景。<br>rho：极径分辨率，以像素为单位，表示极坐标系中的距离分辨率。<br>theta：极角分辨率，以弧度为单位，表示极坐标系中角度的分辨率。<br>threshold：阈值，用于过滤掉弱检测结果，只有累计投票数超过这个阈值的直线才会被返回。<br>lines（可选）：一个可初始化的输出数组，用于存储检测到的直线参数。<br>minLineLength（可选）：最短长度阈值，比这个长度短的线会被排除。<br>maxLineGap（可选）：同一直线两点之间的最大距离。当霍夫变换检测到一系列接近直角的线段时，这些线段可能是同一直线的不同部分。<br>注意：</p>
<ol>
<li>minLineLength 太小：可能会检测到很多短的线段，这些线段可能是噪声或不相关的边缘，增加计算量且降低检测结果的可靠性。</li>
<li>minLineLength 太大：可能会漏掉一些较短但重要的线段，影响车道线的完整性。</li>
<li>maxLineGap 太小：可能会导致一些连续的线段被分割成多段，无法正确表示实际的车道线。<br>4.maxLineGap 太大：可能会将不相关的线段合并在一起，导致误检。<br>对于公路识别原图：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv    </span><br><span class="line">import numpy as np</span><br><span class="line">img=cv.imread(&#x27;../images/daolu.jpg&#x27;)</span><br><span class="line">#降噪</span><br><span class="line">img=cv.GaussianBlur(img,(3,3),0)</span><br><span class="line">img_g=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">dst=cv.Canny(img_g,50,80)</span><br><span class="line">#统计概率霍夫直线变换</span><br><span class="line">lines=cv.HoughLinesP(dst,1,np.pi/180,100,minLineLength=130,maxLineGap=50)#参数:图片,rho精度,theta精度,阈值,最小线段长度,最大线段间隔</span><br><span class="line"></span><br><span class="line">#遍历取得数据</span><br><span class="line">img_c=img.copy()</span><br><span class="line">for line in lines:</span><br><span class="line">    x1,y1,x2,y2=line[0]</span><br><span class="line">    cv.line(img_c,(x1,y1),(x2,y2),(0,255,0),1,cv.LINE_AA)</span><br><span class="line">cv.imshow(&#x27;img_c&#x27;,img_c)</span><br><span class="line">cv.imshow(&#x27;img&#x27;,img)</span><br><span class="line">cv.imshow(&#x27;dst&#x27;,dst)</span><br><span class="line">cv.waitKey()</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-20-2-3霍夫圆变换"><a href="#4-20-2-3霍夫圆变换" class="headerlink" title="4.20.2.3霍夫圆变换"></a>4.20.2.3霍夫圆变换</h5><p>circles&#x3D;cv2.HoughCircles(image, method, dp, minDist, param1, param2)</p>
<p>image：输入图像，通常是灰度图像。</p>
<p>method：使用的霍夫变换方法:霍夫梯度法，可以是 cv2.HOUGH_GRADIENT，这是唯一在OpenCV中用于圆检测的方法。</p>
<p>dp：累加器分辨率与输入图像分辨率之间的降采样比率，用于加速运算但不影响准确性。设置为1表示霍夫梯度法中累加器图像的分辨率与原图一致</p>
<p>minDist：检测到的圆心之间的最小允许距离，以像素为单位。在霍夫变换检测圆的过程中，可能会检测到许多潜在的圆心。minDist 参数就是为了过滤掉过于接近的圆检测结果，避免检测结果过于密集。当你设置一个较小的 minDist 值时，算法会尝试找出尽可能多的圆，即使是彼此靠得很近的圆也可能都被检测出来。相反，当你设置一个较大的 minDist 值时，算法会倾向于只检测那些彼此间存在一定距离的独立的圆。</p>
<p>param1 和 param2：这两个参数是在使用 cv2.HOUGH_GRADIENT 方法时的特定参数，分别为：</p>
<p>param1(可选)：阈值1，决定边缘强度的阈值。</p>
<p>param2：阈值2，控制圆心识别的精确度。较大的该值会使得检测更严格的圆。param2 通常被称为圆心累积概率的阈值。在使用霍夫梯度方法时，param2 设置的是累加器阈值，它决定了哪些候选圆点集合被认为是有效的圆。较高的 param2 值意味着对圆的检测更严格，只有在累加器中积累了足够高的响应值才认为是真实的圆；较低的 param2 值则会降低检测的门槛，可能会检测到更多潜在的圆，但也可能包含更多的误检结果。</p>
<p>返回值：cv2.HoughCircles 返回一个二维numpy数组，包含了所有满足条件的圆的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">img=cv.imread(&#x27;../images/huofu.png&#x27;)</span><br><span class="line">imd_g=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">dst=cv.Canny(imd_g,30,70)</span><br><span class="line">circles=cv.HoughCircles(dst,cv.HOUGH_GRADIENT,1,20,param2=30)</span><br><span class="line">circles=np.int_(circles)</span><br><span class="line">for i in circles:</span><br><span class="line">    x,y,r=i[0]</span><br><span class="line">    cv.circle(img,(x,y),r,(0,255,0),2)</span><br><span class="line">cv.imshow(&#x27;img&#x27;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-21图像亮度变换"><a href="#4-21图像亮度变换" class="headerlink" title="4.21图像亮度变换"></a>4.21图像亮度变换</h3><h4 id="4-21-1步骤"><a href="#4-21-1步骤" class="headerlink" title="4.21.1步骤"></a>4.21.1步骤</h4><p>读图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#读图</span><br><span class="line">img=cv.imread(&#x27;../images/cat1.png&#x27;)</span><br></pre></td></tr></table></figure>

<p>使用cv2.addweighted(sr1,alpha,sr2,beta,gamma)函数(输入图像，权重，输出图像，权重，偏移量(亮度))</p>
<p>将原图的所有像素值带入计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot; </span><br><span class="line">np.zeros_like(img)：返回一个与img相同形状和类型的零数组。</span><br><span class="line">np.ones_like(img)：返回一个与img相同形状和类型的1数组。</span><br><span class="line">np.full_like(img,value)：返回一个与img相同形状和类型的value数组。</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">dst=cv.addWeighted(img,1,np.zeros_like(img),1,200)</span><br></pre></td></tr></table></figure>

<p>cv2.addWeighted(src1, alpha, src2, beta, gamma)**</p>
<ul>
<li><p><code>src1</code>：第一张输入图像，它将被赋予权重 <code>alpha</code>。</p>
</li>
<li><p><code>alpha</code>：第一个输入图像的权重。</p>
</li>
<li><p><code>src2</code>：第二张输入图像，它将被赋予权重 <code>beta</code>。</p>
</li>
<li><p><code>beta</code>：第二个输入图像的权重。</p>
</li>
<li><p><code>gamma</code>：一个标量，将被添加到权重求和的结果上，可用于调整总体亮度。</p>
</li>
</ul>
<p>计算公式为: dst &#x3D; src1 * alpha + src2 * beta + gamma</p>
<p>滑条控制图像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot; </span><br><span class="line">原图：img</span><br><span class="line">输出：dst=img+p</span><br><span class="line">防止溢出：np.clip(dst,0,255)</span><br><span class="line">用一个滑条来控制p的值，p=0时，输出与原图相同，p=255时，输出全黑</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>cv.createTrackbar(trackbarName,windowName,value,count,onChange)</p>
<p>clip&#x3D;np.clip(img,50,180)</p>
<p>再利用np.clip修改数值小于所给的阈值，变成所给阈值，大于所给阈值，也修改为对应阈值</p>
<p>给滑条创建窗口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#给滑条创建窗口</span><br><span class="line">win_name=&#x27;trackbar&#x27;</span><br><span class="line">cv.namedWindow(win_name)</span><br><span class="line">def onChange(p):</span><br></pre></td></tr></table></figure>

<p>再将滑条映射到[-255,255]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def onChange(p):</span><br><span class="line">    #把滑条值映射到[-255,255]</span><br><span class="line">    p=p/255*(255-(-255))-255</span><br><span class="line">    #读图</span><br><span class="line">    dst=np.uint8(np.clip(img+p,0,255))</span><br><span class="line">    cv.imshow(&#x27;img&#x27;,img)</span><br><span class="line">    cv.imshow(&#x27;dst&#x27;,dst)</span><br></pre></td></tr></table></figure>

<p>设置初始参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max_val=255#最大值</span><br><span class="line">trackbar_name=&#x27;p_value&#x27;#滑条名字</span><br><span class="line">initial_value=150#初始值</span><br></pre></td></tr></table></figure>

<p>初始化滑条</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onChange(initial_value)</span><br></pre></td></tr></table></figure>

<p>创建滑条</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv.createTrackbar(trackbar_name,win_name,0,max_val,onChange)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>


        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>CXZ</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://cxz-deman.github.io/2025/04/20/OpenCV%E5%A4%84%E7%90%86%E5%9B%BE%E5%83%8F/">https://cxz-deman.github.io/2025/04/20/OpenCV%E5%A4%84%E7%90%86%E5%9B%BE%E5%83%8F/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>god</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%90%88%E9%9B%86/"># 阶段学习笔记合集</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2025/03/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E6%96%B9%E5%BA%93/">常用的三方库</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© CXZ | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>