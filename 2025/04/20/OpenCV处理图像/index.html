<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="CXZ">





<title>OpenCV处理图像 | CXZ_note</title>



    <link rel="icon" href="/head.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 7.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">CXZ&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">CXZ&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">OpenCV处理图像</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">CXZ</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 20, 2025&nbsp;&nbsp;11:56:22</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h1><h2 id="1-学前准备"><a href="#1-学前准备" class="headerlink" title="1.学前准备"></a>1.学前准备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install OpenCV-python</span><br></pre></td></tr></table></figure>

<p>测试能否正常使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">print(cv2.__version__)</span><br></pre></td></tr></table></figure>

<h2 id="2-图片基本处理"><a href="#2-图片基本处理" class="headerlink" title="2.图片基本处理"></a>2.图片基本处理</h2><h3 id="2-1图片读取"><a href="#2-1图片读取" class="headerlink" title="2.1图片读取"></a>2.1图片读取</h3><p>cv.imread(文件地址)</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">path = &quot;./imgs/cat1.png&quot;</span><br><span class="line">img=cv.imread(path,cv.IMREAD_COLOR)</span><br><span class="line">cv.imshow(&quot;cat_pic&quot;,img)</span><br><span class="line">h,w,c=img.shape</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="2-2numpy数组转化为图片"><a href="#2-2numpy数组转化为图片" class="headerlink" title="2.2numpy数组转化为图片"></a>2.2numpy数组转化为图片</h3><p>创建一个三维的数组</p>
<p>大小为：height*weight*3（颜色通道），数据类型转化为uint8</p>
<p>img&#x3D;np.zeros((height,width,3),np.uint8)#参数：宽，高，通道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import cv2 </span><br><span class="line">import numpy as np</span><br><span class="line">height,width = 480,640</span><br><span class="line">img=np.zeros((height,width,3),np.uint8)#参数：宽，高，通道</span><br><span class="line">print(img.shape)</span><br><span class="line">img[:,:,:]=np.random.randint(125,255,img.shape)#random.randint参数：随机数范围，图片尺寸</span><br><span class="line">print(img.shape)#打印图片的尺寸</span><br><span class="line">#打印图片维度</span><br><span class="line">print(img.ndim)</span><br><span class="line">cv2.imshow(&quot;img&quot;,img)#显示图片</span><br><span class="line">cv2.waitKey(0)#等待键盘输入</span><br><span class="line">cv2.destroyAllWindows()#销毁所有窗口</span><br></pre></td></tr></table></figure>

<h3 id="2-3在图片里绘制图形"><a href="#2-3在图片里绘制图形" class="headerlink" title="2.3在图片里绘制图形"></a>2.3在图片里绘制图形</h3><h4 id="2-3-1绘制直线"><a href="#2-3-1绘制直线" class="headerlink" title="2.3.1绘制直线"></a>2.3.1绘制直线</h4><p>cv.line(参数：图片，起始点，终止点，颜色，线宽)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">cat=cv.imread(&#x27;./imgs/cat1.png&#x27;)</span><br><span class="line">cv.line(cat,(0,0),(cat.shape[1],cat.shape[0]),(0,255,0),2)#参数：图片，起始点，终止点，颜色，线宽</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2绘制圆形"><a href="#2-3-2绘制圆形" class="headerlink" title="2.3.2绘制圆形"></a>2.3.2绘制圆形</h4><p>cv.cirle(参数：图片，圆心，半径，颜色，线宽 线宽为-1则填充为实心圆)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.circle(cat,(cat.shape[1]//2,cat.shape[0]//2),100,(0,255,0),-1)#参数：图片，圆心，半径，颜色，线宽 线宽为-1则填充为实心圆</span><br></pre></td></tr></table></figure>

<h4 id="2-3-3绘制矩形"><a href="#2-3-3绘制矩形" class="headerlink" title="2.3.3绘制矩形"></a>2.3.3绘制矩形</h4><p>cv.rectangle(参数：图片，左上角点，右下角点，颜色，线宽,-1，填充为实心)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.rectangle(cat,(cat.shape[1],cat.shape[0]),(cat.shape[1]//4*3,cat.shape[0]//4*3),(0,255,0),-1)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-4绘制文字（仅英文）"><a href="#2-3-4绘制文字（仅英文）" class="headerlink" title="2.3.4绘制文字（仅英文）"></a>2.3.4绘制文字（仅英文）</h4><p>cv.putText(参数：图片，字，坐标，字体，字体大小，颜色，线宽)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.putText(cat,&#x27;Hello&#x27;,(cat.shape[1]//2,cat.shape[0]//2),cv.FONT_HERSHEY_SIMPLEX,1,(0,0,255),2)</span><br></pre></td></tr></table></figure>

<p>线的类型：#cv.LINE_AA为抗锯齿: cv.LINE_AA, cv.LINE_4, cv.LINE_8, cv.LINE_AA</p>
<h2 id="3-视频处理"><a href="#3-视频处理" class="headerlink" title="3.视频处理"></a>3.视频处理</h2><h3 id="3-1读取视频"><a href="#3-1读取视频" class="headerlink" title="3.1读取视频"></a>3.1读取视频</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">cap=cv.VideoCapture(&#x27;./img/7233x3100 (4).mp4&#x27;)</span><br><span class="line">while True:</span><br><span class="line">    ret,frame=cap.read()#参数为True时，读取下一帧，为False时，读取最后一帧</span><br><span class="line">    if ret==False:</span><br><span class="line">        print(&#x27;读取失败&#x27;)</span><br><span class="line">        break</span><br><span class="line">    cv.imshow(&#x27;frame&#x27;,frame)</span><br><span class="line">    if cv.waitKey(40)&amp;0xFF==ord(&#x27;q&#x27;):#意思：回第八位的值，0xFF为十六进制的FF，即二进制的11111111</span><br><span class="line">        break</span><br><span class="line">cap.release()  </span><br><span class="line">cv.destroyAllWindows()  </span><br></pre></td></tr></table></figure>

<h2 id="4-图像预处理"><a href="#4-图像预处理" class="headerlink" title="4.图像预处理"></a>4.图像预处理</h2><h3 id="4-1图像预处理准备"><a href="#4-1图像预处理准备" class="headerlink" title="4.1图像预处理准备"></a>4.1图像预处理准备</h3><p>读取图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">img=cv.imread(&#x27;./imgs/cat1.png&#x27;)</span><br><span class="line">cv.resize(img,(480,480))</span><br><span class="line">cv.imshow(&#x27;cat&#x27;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-2图像翻转"><a href="#4-2图像翻转" class="headerlink" title="4.2图像翻转"></a>4.2图像翻转</h3><p><strong>cv2.flip(img,flipcode)</strong><br>参数：</p>
<ul>
<li>img: 要翻转的图像</li>
<li>flipcode: 指定翻转类型的标志<ul>
<li>flipcode&#x3D;0: 垂直翻转，图片像素点沿x轴翻转</li>
<li>flipcode&gt;0: 水平翻转，图片像素点沿y轴翻转</li>
<li>flipcode&lt;0: 沿原点翻转，与原图中心对称</li>
</ul>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat_fx=cv.flip(img,0)</span><br><span class="line">cat_fy=cv.flip(img,1)</span><br><span class="line">cat_fxy=cv.flip(img,-1)</span><br><span class="line">cv.imshow(&#x27;cat&#x27;,img)</span><br><span class="line">cv.imshow(&#x27;cat_fx&#x27;,cat_fx)#沿x轴翻转上下</span><br><span class="line">cv.imshow(&#x27;cat_fy&#x27;,cat_fy)#沿y轴翻转左右</span><br><span class="line">cv.imshow(&#x27;cat_fxy&#x27;,cat_fxy)#沿着原点中心翻转</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-3图像仿射变换"><a href="#4-3图像仿射变换" class="headerlink" title="4.3图像仿射变换"></a>4.3<strong>图像仿射变换</strong></h3><p>使用关键仿射变换函数</p>
<p>cv.warpAffline(参数：图片名,仿射变换矩阵,图片大小,插值方法)</p>
<p>得到仿射变换矩阵M –&gt; 带入仿射变换函数 –&gt; 输出</p>
<h4 id="4-3-1图像旋转"><a href="#4-3-1图像旋转" class="headerlink" title="4.3.1图像旋转"></a>4.3.1图像旋转</h4><p>设置参数旋转中心，旋转角度，缩放比例</p>
<p>使用cv.getRotationMatrix2D(设置旋转中心，旋转角度，缩放比例）</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">h,w,_=img.shape</span><br><span class="line">#设置旋转中心</span><br><span class="line">center=(w//2,h//2)</span><br><span class="line">angle=0</span><br><span class="line">scale=0.01#缩放比例</span><br><span class="line">M=cv.getRotationMatrix2D(center,angle,scale)#仿射变换矩阵</span><br><span class="line">#使用仿射变换函数进行变换旋转</span><br><span class="line">img_rotate=cv.warpAffine(img,M,(w,h),flags=cv.INTER_LINEAR)#参数：图片名,仿射变换矩阵,输出图片大小,插值方法</span><br><span class="line">cv.imshow(&#x27;img_rotate&#x27;,img_rotate)</span><br><span class="line">cv.imshow(&#x27;cat&#x27;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2图像平移"><a href="#4-3-2图像平移" class="headerlink" title="4.3.2图像平移"></a>4.3.2图像平移</h4><p>平移：读取图像-》设置参数（平移量tx，ty）-》获取平移矩阵np.float32-》仿射变换函数进行平移-》显示图像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tx = 200</span><br><span class="line">ty = 100</span><br><span class="line">M = np.float32([[1,0,tx],[0,1,ty]])</span><br><span class="line">print(M)</span><br><span class="line"></span><br><span class="line">img_remove = cv.warpAffine(img,M,(w,h))#挪移后多余的像素点舍弃</span><br><span class="line">cv.imshow(&#x27;img_remove&#x27;,img_remove)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3图像缩放"><a href="#4-3-3图像缩放" class="headerlink" title="4.3.3图像缩放"></a>4.3.3图像缩放</h4><p>M仿射矩阵：设置缩放比例</p>
<p>M &#x3D; np.float32([[缩放比例, 0, 0], [0, 缩放比例, 0]])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#读取图像</span><br><span class="line">M = np.float32([[0.1, 0, 0], [0, 0.1, 0]])</span><br><span class="line">img_little = cv.warpAffine(img, M, (img.shape[1], img.shape[0]))</span><br><span class="line">cv.imshow(&#x27;img&#x27;,img_little)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>4.3.4图像剪切</p>
<p>示例代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np </span><br><span class="line">import cv2 as cv</span><br><span class="line">#读取图像</span><br><span class="line">shx=0.2</span><br><span class="line">shy=0.2</span><br><span class="line">img=cv.imread(&#x27;./imgs/cat1.png&#x27;)</span><br><span class="line">img=cv.resize(img,(300,300))</span><br><span class="line">M_y = np.float32([[1,shy, 0], [0, 1, 0]])</span><br><span class="line">M_x = np.float32([[1, 0, 0], [shx, 1, 0]])</span><br><span class="line">M_xy= np.float32([[1,shy, 0], [shx, 1, 0]])</span><br><span class="line">M= np.float32([[1,0, 0], [0, 1, 0]])</span><br><span class="line">img_little_y = cv.warpAffine(img, M_y, (360, 360))</span><br><span class="line">img_little_x = cv.warpAffine(img, M_x, (360, 360))</span><br><span class="line">img_little_xy = cv.warpAffine(img, M_xy, (360, 360))</span><br><span class="line">img_li=cv.warpAffine(img, M, (360, 360))</span><br><span class="line">cv.imshow(&#x27;img_y&#x27;,img_little_y)</span><br><span class="line">cv.imshow(&#x27;img_x&#x27;,img_little_x)</span><br><span class="line">cv.imshow(&#x27;img_xy&#x27;,img_little_xy)</span><br><span class="line">cv.imshow(&#x27;img_li&#x27;,img_li)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>4.4图片压缩</p>
<p>4.4.1最近邻插值法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_img=cv.warpAffine(img,M,(300,300),flags=cv.INTER_NEAREST)</span><br><span class="line">cv.imshow(&quot;new_img&quot;,new_img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>4.4.2双线性插值法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new_img=cv.warpAffine(img,M,(300,300),flags=cv.INTER_LINEAR)</span><br><span class="line">cv.imshow(&quot;new_img&quot;,new_img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>4.4.3像素区域插值法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">st=cv.imread(&#x27;./img/blackstocking.png&#x27;)</span><br><span class="line">st=cv.resize(st,(160,240))</span><br><span class="line">dst_x=cv.warpAffine(st,M,(160,240),flags=cv.INTER_NEAREST)</span><br><span class="line">dst_l=cv.warpAffine(st,M,(160,240),flags=cv.INTER_LINEAR)</span><br><span class="line">dst_c=cv.warpAffine(st,M,(160,240),flags=cv.INTER_AREA)#像素区域插值</span><br><span class="line">cv.imshow(&#x27;st&#x27;,st)</span><br><span class="line">cv.imshow(&#x27;dst_x&#x27;,dst_x)</span><br><span class="line">cv.imshow(&#x27;dst_l&#x27;,dst_l)</span><br><span class="line">cv.imshow(&#x27;dst_c&#x27;,dst_c)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4其他方法"><a href="#4-3-4其他方法" class="headerlink" title="4.3.4其他方法"></a>4.3.4其他方法</h4><h5 id="4-4-4-1双三次插值法"><a href="#4-4-4-1双三次插值法" class="headerlink" title="4.4.4.1双三次插值法"></a>4.4.4.1双三次插值法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.warpAffine(img,M,(cols,rows),flags=cv.INTER_CUBIC)</span><br></pre></td></tr></table></figure>

<h5 id="4-4-4-2Lanczos插值"><a href="#4-4-4-2Lanczos插值" class="headerlink" title="4.4.4.2Lanczos插值"></a>4.4.4.2Lanczos插值</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.warpAffine(img,M,(cols,rows),flags=cv.INTER_LANCZOS4)</span><br></pre></td></tr></table></figure>

<h3 id="4-5图像边缘填充"><a href="#4-5图像边缘填充" class="headerlink" title="4.5图像边缘填充"></a>4.5图像边缘填充</h3><h4 id="4-5-1边缘填充准备"><a href="#4-5-1边缘填充准备" class="headerlink" title="4.5.1边缘填充准备"></a>4.5.1边缘填充准备</h4><p>旋转缩放图像做准备</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">face=cv.imread(&quot;./images/face.png&quot;)</span><br><span class="line">#获取旋转矩阵</span><br><span class="line">scale=0.1</span><br><span class="line">angle=45</span><br><span class="line">center=(face.shape[1]//2,face.shape[0]//2)</span><br><span class="line">M=cv.getRotationMatrix2D(center,angle,scale)</span><br><span class="line">#使用仿射变换矩阵</span><br><span class="line">img=cv.warpAffine(face,M,(face.shape[1],face.shape[0]))</span><br><span class="line">cv.imshow(&quot;img&quot;,img)    </span><br><span class="line">cv.imshow(&quot;face&quot;,face)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-2边缘复制"><a href="#4-5-2边缘复制" class="headerlink" title="4.5.2边缘复制"></a>4.5.2边缘复制</h4><p>cv.warpAffine(<strong>参数：图像，输出图片大小，插值方式，边界模式</strong></p>
<p>borderMode&#x3D;cv.BORDER_REPLICATE</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">img_boradercv=cv.warpAffine(face,M,(face.shape[1],face.shape[0]),cv.INTER_LANCZOS4,borderMode=cv.BORDER_REPLICATE)</span><br><span class="line">cv.imshow(&quot;img&quot;,img)    </span><br><span class="line">cv.imshow(&quot;face&quot;,face)</span><br><span class="line">cv.imshow(&quot;img_boradercv&quot;,img_boradercv)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-3边界反射"><a href="#4-5-3边界反射" class="headerlink" title="4.5.3边界反射"></a>4.5.3边界反射</h4><p>borderMode&#x3D;cv.BORDER_REFLECT</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img_reflect = cv.warpAffine(face,M,(face.shape[1],face.shape[0]), cv.INTER_LANCZOS4,borderMode=cv.BORDER_REFLECT)</span><br><span class="line">cv.imshow(&#x27;reflect&#x27;, img_reflect)</span><br><span class="line">cv.imshow(&quot;img&quot;,img)    </span><br><span class="line">cv.imshow(&quot;face&quot;,face)</span><br><span class="line">cv.imshow(&quot;img_boradercv&quot;,img_boradercv)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-4边界反射-101"><a href="#4-5-4边界反射-101" class="headerlink" title="4.5.4边界反射_101"></a>4.5.4边界反射_101</h4><p>borderMode&#x3D;cv.BORDER_REFLECT101</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img_reflect101=cv.warpAffine(face,M,dsize=(img.shape[1],img.shape[0]),flags=cv.INTER_LINEAR,borderMode=cv.BORDER_REFLECT101)</span><br><span class="line">cv.imshow(&#x27;reflect&#x27;, img_reflect)</span><br><span class="line">cv.imshow(&quot;img&quot;,img)    </span><br><span class="line">cv.imshow(&quot;face&quot;,face)</span><br><span class="line">cv.imshow(&quot;img_boradercv&quot;,img_boradercv)</span><br><span class="line">cv.imshow(&quot;img_reflect101&quot;,img_reflect101)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-5边缘常数填充"><a href="#4-5-5边缘常数填充" class="headerlink" title="4.5.5边缘常数填充"></a>4.5.5边缘常数填充</h4><p>borderMode&#x3D;cv.BORDER_CONSTANT,borderValue&#x3D;(0,0,255)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_ch=cv.warpAffine(face,M,(face.shape[1],face.shape[0]),cv.INTER_LANCZOS4,borderMode=cv.BORDER_CONSTANT,borderValue=(0,0,255))</span><br><span class="line">cv.imshow(&#x27;img_ch&#x27;,img_ch)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-5-6边缘包裹"><a href="#4-5-6边缘包裹" class="headerlink" title="4.5.6边缘包裹"></a>4.5.6边缘包裹</h4><p>borderMode&#x3D;cv.BORDER_WRAP</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_wrap=cv.warpAffine(face,M,(face.shape[<span class="number">1</span>],face.shape[<span class="number">0</span>]),cv.INTER_LANCZOS4,borderMode=cv.BORDER_WRAP)</span><br><span class="line">cv.imshow(<span class="string">&#x27;wrap&#x27;</span>,img_wrap)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-6图像矫正（透视变换）"><a href="#4-6图像矫正（透视变换）" class="headerlink" title="4.6图像矫正（透视变换）"></a>4.6图像矫正（透视变换）</h3><p>步骤：对原图需要矫正位置的坐标进行框中选定，输出图像的大小坐标分别创建两个numpy数组</p>
<p>使用cv.getPerspectiveTransform(pic1,pic_2)创建仿射变换矩阵M</p>
<p>使用cv.warpPerspective(img_tou,M,(w,h),flags&#x3D;cv.INTER_LINEAR,borderMode&#x3D;cv.BORDER_CONSTANT)</p>
<p>cv.warpPerspective(参数：图像片，变换矩阵，输出尺寸，插值方法，边界填充方式)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">pic1=np.float32([[182,113],[521,141],[115,294],[501,340]])</span><br><span class="line">print(pic1[0].shape)</span><br><span class="line"></span><br><span class="line">M = cv.getPerspectiveTransform(pic1,pic_2)</span><br><span class="line">new_img=new_pic = cv.warpPerspective(img_tou,M,(w,h),flags=cv.INTER_LINEAR,borderMode=cv.BORDER_CONSTANT)#参数：图像片，变换矩阵，输出尺寸，插值方法，边界填充方式</span><br><span class="line">cv.imshow(&#x27;new_img&#x27;,new_img)</span><br><span class="line">cv.imshow(&#x27;img_tou&#x27;,img_tou)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-7图像叠加"><a href="#4-7图像叠加" class="headerlink" title="4.7图像叠加"></a>4.7图像叠加</h3><h4 id="4-7-1直接相加"><a href="#4-7-1直接相加" class="headerlink" title="4.7.1直接相加"></a>4.7.1直接相加</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pig=cv.imread(&#x27;./images/pig.png&#x27;)</span><br><span class="line">cao=cv.imread(&#x27;./images/cao.png&#x27;)</span><br><span class="line">img_numpy=cao+pig</span><br><span class="line">print(img_numpy)</span><br></pre></td></tr></table></figure>

<h4 id="4-7-2add函数饱和运算"><a href="#4-7-2add函数饱和运算" class="headerlink" title="4.7.2add函数饱和运算"></a>4.7.2add函数饱和运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img_add=cv.add(pig,cao)</span><br><span class="line">print(cv.add(pig,cao))#add函数</span><br></pre></td></tr></table></figure>

<h4 id="4-7-3加权求和运算"><a href="#4-7-3加权求和运算" class="headerlink" title="4.7.3加权求和运算"></a>4.7.3加权求和运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img_weight=cv.addWeighted(pig,0.5,cao,0.5,0)#加权求和运算·</span><br></pre></td></tr></table></figure>

<h3 id="4-8图像处理转换"><a href="#4-8图像处理转换" class="headerlink" title="4.8图像处理转换"></a>4.8图像处理转换</h3><p>函数cv.cvtcolor(参数：转换方式)</p>
<h4 id="4-8-1rgb转换为gray"><a href="#4-8-1rgb转换为gray" class="headerlink" title="4.8.1rgb转换为gray"></a>4.8.1rgb转换为gray</h4><p>cat_grey&#x3D;cv.cvtColor(cat,cv.COLOR_RGB2GRAY)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">cat=cv.imread(&#x27;./images/cat1.png&#x27;)</span><br><span class="line">cv.imshow(&#x27;cat&#x27;,cat)</span><br><span class="line">cat_grey=cv.cvtColor(cat,cv.COLOR_RGB2GRAY)</span><br><span class="line">cv.imshow(&#x27;cat_grey&#x27;,cat_grey)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-8-2rgb转换为hsv"><a href="#4-8-2rgb转换为hsv" class="headerlink" title="4.8.2rgb转换为hsv"></a>4.8.2rgb转换为hsv</h4><p>cat_hsv&#x3D;cv.cvtColor(cat,cv.COLOR_BGR2HSV)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat_hsv=cv.cvtColor(cat,cv.COLOR_BGR2HSV)</span><br><span class="line">cv.imshow(&quot;cat_hsv&quot;,cat_hsv)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-9灰度实验"><a href="#4-9灰度实验" class="headerlink" title="4.9灰度实验"></a>4.9灰度实验</h3><h4 id="4-9-1最大值灰度转换"><a href="#4-9-1最大值灰度转换" class="headerlink" title="4.9.1最大值灰度转换"></a>4.9.1最大值灰度转换</h4><p>使用for循环迭代，取颜色通道中的最大值，并且赋值到颜色通道上去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">pig_y=cv.imread(&#x27;./images/pig.png&#x27;)</span><br><span class="line">pig=cv.imread(&#x27;./images/pig.png&#x27;)</span><br><span class="line">for i in range(pig.shape[0]):</span><br><span class="line">    for j in range(pig.shape[1]):</span><br><span class="line">        pig[i][j][0]=max(pig[i][j])</span><br><span class="line">        pig[i][j][1]=max(pig[i][j])</span><br><span class="line">        pig[i][j][2]=max(pig[i][j])</span><br><span class="line">cv.imshow(&#x27;pig&#x27;,pig)</span><br><span class="line">cv.imshow(&#x27;pig_y&#x27;,pig_y)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-9-2平均值灰度"><a href="#4-9-2平均值灰度" class="headerlink" title="4.9.2平均值灰度"></a>4.9.2平均值灰度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">pig = cv.imread(&quot;./images/pig.png&quot;)</span><br><span class="line">h,w,_ = pig.shape</span><br><span class="line">av_grey=np.zeros((h,w),dtype=np.uint8)#uint8:0~255</span><br><span class="line">for i in range(h):</span><br><span class="line">    for j in range(w):</span><br><span class="line">        av_grey[i,j] = int(sum((pig[i,j])))//3</span><br><span class="line">cv.imshow(&quot;av&quot;,av_grey)</span><br><span class="line">cv.imshow(&quot;pig&quot;,pig)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-9-3加权灰度"><a href="#4-9-3加权灰度" class="headerlink" title="4.9.3加权灰度"></a>4.9.3加权灰度</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wr,wg,wb=0.299,0.576,0.114</span><br><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">pig = cv.imread(&quot;./images/pig.png&quot;)</span><br><span class="line">h,w,_ = pig.shape</span><br><span class="line">weight_grey=np.zeros((h,w),dtype=np.uint8)#uint8:0~255</span><br><span class="line">for i in range(h):</span><br><span class="line">    for j in range(w):</span><br><span class="line">        weight_grey[i,j] = np.array([pig[i,j,0]*wr,pig[i,j,1]*wg,pig[i,j,2]*wb]).sum()/3</span><br><span class="line">cv.imshow(&quot;av&quot;,weight_grey)</span><br><span class="line">cv.imshow(&quot;pig&quot;,pig)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-10图像二值化处理"><a href="#4-10图像二值化处理" class="headerlink" title="4.10图像二值化处理"></a>4.10图像二值化处理</h3><p><em><strong>cv.threshold(图片，阈值，maxval，方法)</strong></em></p>
<h4 id="4-10-1阈值法-cv-THRESH-BINARY"><a href="#4-10-1阈值法-cv-THRESH-BINARY" class="headerlink" title="4.10.1阈值法(cv.THRESH_BINARY)"></a>4.10.1阈值法(cv.THRESH_BINARY)</h4><p>小于等于阈值的像素就被设置为0（通常代表背景），大于阈值的像素就被设置为maxval（通常代表前景）</p>
<h4 id="4-10-2反阈值法-THRESH-BINARY-INV"><a href="#4-10-2反阈值法-THRESH-BINARY-INV" class="headerlink" title="4.10.2反阈值法(THRESH_BINARY_INV)"></a>4.10.2反阈值法(THRESH_BINARY_INV)</h4><p>像素值大于阈值时，该像素值将会变成0（黑），当灰度图的像素值小于等于阈值时，该像素值将会变成maxval</p>
<h4 id="4-10-3截断阈值法-THRESH-TRUNC"><a href="#4-10-3截断阈值法-THRESH-TRUNC" class="headerlink" title="4.10.3截断阈值法(THRESH_TRUNC)"></a>4.10.3截断阈值法(THRESH_TRUNC)</h4><p>像素值大于阈值的部分将会被修改为阈值，小于等于阈值的部分不变。</p>
<h4 id="4-10-4低阈值零处理-THRESH-TOZERO"><a href="#4-10-4低阈值零处理-THRESH-TOZERO" class="headerlink" title="4.10.4低阈值零处理(THRESH_TOZERO)"></a>4.10.4低阈值零处理(THRESH_TOZERO)</h4><p>像素值小于等于阈值的部分被置为0（也就是黑色），大于阈值的部分不变。</p>
<h4 id="4-10-5超阈值零处理-THRESH-TOZERO-INV"><a href="#4-10-5超阈值零处理-THRESH-TOZERO-INV" class="headerlink" title="4.10.5超阈值零处理(THRESH_TOZERO_INV)"></a>4.10.5超阈值零处理(THRESH_TOZERO_INV)</h4><p>像素值大于阈值的部分置为0（也就是黑色），像素值小于等于阈值的部分不变。</p>
<h4 id="4-10-6OSTU阈值法-THRESH-OTSU"><a href="#4-10-6OSTU阈值法-THRESH-OTSU" class="headerlink" title="4.10.6OSTU阈值法(THRESH_OTSU)"></a>4.10.6OSTU阈值法(THRESH_OTSU)</h4><p>采取最大类间距的策略，该方法是使用是寻找最佳阈值</p>
<h4 id="4-10-7自适应二值法"><a href="#4-10-7自适应二值法" class="headerlink" title="4.10.7自适应二值法"></a>4.10.7自适应二值法</h4><p><em><strong>cv.adaptiveThreshold(参数1：灰度图，参数2：最大值，参数3：自适应阈值方法，参数4：二值化方法，参数5：窗口大小，参数6：偏移量)</strong></em></p>
<p>明暗分布不均匀可以使用自适应二值化</p>
<h5 id="4-10-7-1均值法-ADAPTIVE-THRESH-MEAN-C"><a href="#4-10-7-1均值法-ADAPTIVE-THRESH-MEAN-C" class="headerlink" title="4.10.7.1均值法(ADAPTIVE_THRESH_MEAN_C)"></a>4.10.7.1均值法(ADAPTIVE_THRESH_MEAN_C)</h5><p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_mean=cv.adaptiveThreshold(gray,255,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY,5,10)</span><br><span class="line">cv.imshow(&#x27;mean&#x27;,img_mean)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-10-7-2加权求和法-ADAPTIVE-THRESH-GAUSSIAN-C"><a href="#4-10-7-2加权求和法-ADAPTIVE-THRESH-GAUSSIAN-C" class="headerlink" title="4.10.7.2加权求和法(ADAPTIVE_THRESH_GAUSSIAN_C)"></a>4.10.7.2加权求和法(ADAPTIVE_THRESH_GAUSSIAN_C)</h5><p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_guss=cv.adaptiveThreshold(gray,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY,11,2)</span><br><span class="line">cv.imshow(&#x27;img_guss&#x27;,img_guss)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-11制作图像掩膜"><a href="#4-11制作图像掩膜" class="headerlink" title="4.11制作图像掩膜"></a>4.11制作图像掩膜</h3><h4 id="4-11-1制作掩膜及其修改颜色步骤"><a href="#4-11-1制作掩膜及其修改颜色步骤" class="headerlink" title="4.11.1制作掩膜及其修改颜色步骤"></a>4.11.1制作掩膜及其修改颜色步骤</h4><ul>
<li><p>图像掩膜是图像处理中的一个重要概念，它用于对图像进行遮罩，从而实现对图像的裁剪、过滤、增强等操作。</p>
</li>
<li><p>设置：color_low&#x3D;np.array([23,46,46])   color_high&#x3D;np.array([34,255,255])</p>
</li>
<li><p>根据hsv表创建掩膜，最大值和最小值，掩膜输出的是目标区域显示为白色，其他为黑色</p>
</li>
<li><p>参数：src：源图像，lowerb：颜色下限，upperb：颜色上限，dst：输出图像</p>
</li>
<li><p>做与运算输出，输出结果将目标白色替换为原色，其他不变</p>
</li>
</ul>
<p>颜色bgr转hsv </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">demo=cv.imread(&quot;./images/demo.png&quot;)</span><br><span class="line">demo=cv.resize(demo,(480,480))</span><br><span class="line">#颜色bgr转hsv</span><br><span class="line">demo_hsv=cv.cvtColor(demo,cv.COLOR_BGR2HSV)</span><br></pre></td></tr></table></figure>

<p>创建掩膜：cv.inRange(src,lowerb,upperb,dst) </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#创建掩膜：cv.inRange(src,lowerb,upperb,dst)，参数：src：源图像，lowerb：颜色下限，upperb：颜色上限，dst：输出图像</span><br><span class="line">color_low=np.array([23,46,46])</span><br><span class="line">color_high=np.array([34,255,255])</span><br></pre></td></tr></table></figure>

<p>做与运算输出掩膜cv.bitwise_and(demo,demo,mask&#x3D;mask)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#创建掩膜与原图大小一样，是一个二值化图像</span><br><span class="line">mask=cv.inRange(demo_hsv,color_low,color_high)#只显示黑白色</span><br><span class="line">mask_and=cv.bitwise_and(demo,demo,mask=mask)#做两次运算前两个颜色，再与掩膜运算</span><br></pre></td></tr></table></figure>

<p>将原图目标色进行替换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#修改颜色</span><br><span class="line">demo[mask==255]=[0,255,0]</span><br><span class="line">cv.imshow(&#x27;demo&#x27;,demo)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-11-2掩膜实例–添加水印"><a href="#4-11-2掩膜实例–添加水印" class="headerlink" title="4.11.2掩膜实例–添加水印"></a>4.11.2掩膜实例–添加水印</h4><h5 id="4-11-2-1ROI切割"><a href="#4-11-2-1ROI切割" class="headerlink" title="4.11.2.1ROI切割"></a>4.11.2.1ROI切割</h5><p>也就是使用numpy数组进行切割，不作赘述</p>
<h5 id="4-11-2-2添加水印实例"><a href="#4-11-2-2添加水印实例" class="headerlink" title="4.11.2.2添加水印实例"></a>4.11.2.2添加水印实例</h5><p>步骤：</p>
<p>从原图切下需要添加水印的区域，并进行灰度处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">import numpy as np</span><br><span class="line">logo=cv.imread(&#x27;images/logohq.png&#x27;)</span><br><span class="line">bg=cv.imread(&#x27;images/bg.png&#x27;)</span><br><span class="line">h,w=logo.shape[:2]</span><br><span class="line">logo_grey=cv.cvtColor(logo,cv.COLOR_BGR2GRAY)</span><br><span class="line">bg_zi=bg[:h,:w]</span><br></pre></td></tr></table></figure>

<p>分别将logo图进行二值化，分别使用阈值法和反阈值法进行变换</p>
<p>阈值法白底黑字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_,logo_grey_black=cv.threshold(logo_grey,170,255,cv.THRESH_BINARY)</span><br></pre></td></tr></table></figure>

<p>反阈值法白字黑底</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_,logo_grey_binary=cv.threshold(logo_grey,170,255,cv.THRESH_BINARY_INV)</span><br></pre></td></tr></table></figure>

<p>分别将两个所得图原logo图和截取区域进行与运算</p>
<p>将白字替换为原来的颜色，制作掩膜</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logo_and=cv.bitwise_and(logo,logo,mask=logo_grey_binary)#掩膜</span><br></pre></td></tr></table></figure>

<p>将另一张图的黑字与截取区域作与运算，得到一个黑字logo和原背景图结合的图片</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logo_and_black=cv.bitwise_and(bg_zi,bg_zi,mask=logo_grey_black)</span><br></pre></td></tr></table></figure>

<p>对所得掩膜进行add运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg_zi[:]=cv.add(logo_and,logo_and_black)</span><br></pre></td></tr></table></figure>

<h3 id="4-12噪点消除"><a href="#4-12噪点消除" class="headerlink" title="4.12噪点消除"></a>4.12噪点消除</h3><h5 id="4-12-1均值滤波"><a href="#4-12-1均值滤波" class="headerlink" title="4.12.1均值滤波"></a>4.12.1均值滤波</h5><p>cv.blur(img,(3,3))</p>
<ul>
<li>参数：目标图，核尺寸（只能为单数）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">#均值滤波cv.blur</span><br><span class="line">img=cv.imread(&quot;./images/lvbo2.png&quot;)</span><br><span class="line">img_blur=cv.blur(img,(3,3))#均值滤波</span><br><span class="line">cv.imshow(&quot;img&quot;,img)</span><br><span class="line">cv.imshow(&quot;img_blur&quot;,img_blur)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-12-2方框滤波"><a href="#4-12-2方框滤波" class="headerlink" title="4.12.2方框滤波"></a>4.12.2方框滤波</h5><p>cv.boxFilter(img, -1, (3,3),normalize&#x3D;True、False)</p>
<ul>
<li>参数：输入图像，输出图像的深度，核大小，是否归一化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#方框滤波cv.boxFilter</span><br><span class="line">img_box=cv.boxFilter(img, -1, (3,3),normalize=True)#参数：输入图像，输出图像的深度，核大小，是否归一化</span><br><span class="line">img_box_F=cv.boxFilter(img, -1, (3,3),normalize=False)</span><br><span class="line">cv.imshow(&#x27;img_box&#x27;,img_box)</span><br><span class="line">cv.imshow(&#x27;img_box_F&#x27;,img_box_F)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-12-3高斯滤波"><a href="#4-12-3高斯滤波" class="headerlink" title="4.12.3高斯滤波"></a>4.12.3高斯滤波</h5><p>cv.GaussianBlur(img,(3,3),1)</p>
<ul>
<li>参数：1、原图；2、核大小；3、标准差</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#高斯滤波:好用cv.GaussianBlur</span><br><span class="line">img_gauss=cv.GaussianBlur(img,(3,3),1)#参数：1、原图；2、核大小；3、标准差</span><br><span class="line">cv.imshow(&#x27;img_gauss&#x27;,img_gauss)</span><br><span class="line">cv.imshow(&quot;img&quot;,img)</span><br><span class="line">cv.imshow(&quot;img_blur&quot;,img_blur)    </span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-12-4中值滤波"><a href="#4-12-4中值滤波" class="headerlink" title="4.12.4中值滤波"></a>4.12.4中值滤波</h5><p>cv.medianBlur(img_jy, 5)</p>
<ul>
<li>更适合椒盐噪声</li>
<li>参数1.原图，2.核大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">img_jy=cv.imread(&quot;images/lvbo3.png&quot;)#更适合椒盐噪声</span><br><span class="line">#中值滤波：cv.medianBlur</span><br><span class="line">img_median = cv.medianBlur(img_jy, 5)#参数1.原图，2.核大小</span><br><span class="line">cv.imshow(&quot;median&quot;, img_median)</span><br><span class="line">cv.imshow(&quot;jy&quot;, img_jy)</span><br><span class="line">cv.waitKey(0)   </span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="4-12-5双边滤波"><a href="#4-12-5双边滤波" class="headerlink" title="4.12.5双边滤波"></a>4.12.5双边滤波</h5><p>cv.bilateralFilter(img,9,75,75)</p>
<ul>
<li>参数：图片，区域大小，高斯核，高斯核</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">img_doubleb=cv.bilateralFilter(img,9,75,75)#参数：图片，区域大小，高斯核，高斯核</span><br><span class="line">cv.imshow(&#x27;img_doubleb&#x27;,img_doubleb)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-13图像梯度处理"><a href="#4-13图像梯度处理" class="headerlink" title="4.13图像梯度处理"></a>4.13图像梯度处理</h3><p>滤波是应用卷积来实现的，卷积的关键就是卷积核，我们来考察下面这个卷积核：<br>$$<br>k1&#x3D;\left[\begin{array}{c c c}1&amp;0&amp;1\2&amp;0&amp;2\1&amp;0&amp;1\end{array}\right]<br>$$</p>
<h4 id="4-13-1sobel算子"><a href="#4-13-1sobel算子" class="headerlink" title="4.13.1sobel算子"></a>4.13.1sobel算子</h4><p>cv.Sobel(img,-1,1,1,3)，会进行边缘反射_101，再进行计算</p>
<p>参数：图像，深度，横向，纵向，核大小</p>
<p>横向可以设置1或者0，为1则绘制横向边缘</p>
<p>纵向同理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line">img_sobel=cv.Sobel(img,-1,1,1,3)</span><br><span class="line">img_sobel_x=cv.Sobel(img,-1,1,0,3)#求纵向边缘</span><br><span class="line">img_sobel_y=cv.Sobel(img,-1,0,1,3)#求横向边缘</span><br><span class="line">cv.imshow(&quot;sobel&quot;,img_sobel)</span><br><span class="line">cv.imshow(&quot;sobel_x&quot;,img_sobel_x)</span><br><span class="line">cv.imshow(&quot;sobel_y&quot;,img_sobel_y)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="4-13-2Laplacian算子"><a href="#4-13-2Laplacian算子" class="headerlink" title="4.13.2Laplacian算子"></a>4.13.2Laplacian算子</h4><p>cv.Laplacian(img,-1)</p>
<p>参数：输入图像，输出图像的深度，核大小，偏移量，核类型（以上示例只填写了前两个）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"># 模拟一张图像，灰度图</span><br><span class="line">img=np.array([[100,102,109,110,98,20,19,18,21,22],</span><br><span class="line">             [109,101,98,108,102,20,21,19,20,21],</span><br><span class="line">             [109,102,105,108,98,20,22,19,19,18],</span><br><span class="line">             [109,98,102,108,102,20,23,19,20,22],</span><br><span class="line">             [109,102,105,108,98,20,22,19,20,18],</span><br><span class="line">             [100,102,108,110,98,20,19,18,21,22],</span><br><span class="line">             [109,101,98,108,102,20,22,19,20,21],</span><br><span class="line">             [109,102,108,108,98,20,22,19,19,18],</span><br><span class="line">              ],dtype=np.float32)</span><br><span class="line">img_la=cv.Laplacian(img,-1)#参数：输入图像，输出图像的深度，核大小，偏移量，核类型</span><br><span class="line">print(img)</span><br><span class="line">cv.imshow(&#x27;laplacian&#x27;,img_la)</span><br><span class="line">print(img_la)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[ 22.   3. -28. -17. -58.  77.   4.   6.  -4.  -4.]</span><br><span class="line"> [-25.   7.  31. -14. -84.  83.  -4.   2.   0.  -4.]</span><br><span class="line"> [-14.   5. -10. -13. -60.  80.  -5.   3.   1.   9.]</span><br><span class="line"> [-22.  23.   8. -12. -84.  85.  -9.   5.   0. -12.]</span><br><span class="line"> [-23.   6.   0. -11. -64.  80.  -7.   3.  -2.  12.]</span><br><span class="line"> [ 22.   3. -17. -18. -62.  77.   6.   6.  -4.  -7.]</span><br><span class="line"> [-25.   7.  33. -14. -84.  84.  -8.   3.   0.  -4.]</span><br><span class="line"> [-14.  11. -26. -10. -60.  80.  -5.   3.   1.   8.]]</span><br></pre></td></tr></table></figure>

<h3 id="4-14边缘检测"><a href="#4-14边缘检测" class="headerlink" title="4.14边缘检测"></a>4.14边缘检测</h3><p>不是一个算子，是完整的一整套方案。</p>
<h4 id="4-14-1-高斯滤波"><a href="#4-14-1-高斯滤波" class="headerlink" title="4.14.1 高斯滤波"></a>4.14.1 高斯滤波</h4><p>就是去除噪点！</p>
<p>边缘检测本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理。这里使用的是一个5*5的高斯核对图像进行消除噪声。上一个实验中已经介绍了高斯滤波的具体过程，这里就不再过多叙述，只展示一下用到的5*5的高斯核：</p>
<h4 id="4-14-2-计算图像的梯度与方向"><a href="#4-14-2-计算图像的梯度与方向" class="headerlink" title="4.14.2 计算图像的梯度与方向"></a>4.14.2 计算图像的梯度与方向</h4><p>这里使用了sobel算子来计算图像的梯度值，在上一章节中，我们了解到sobel算子其实就是一个核值固定的卷积核，如下所示：<br>$$<br>sobel(水平方向)&#x3D;\left[\begin{array}{c c c}1&amp;0&amp;1\2&amp;0&amp;2\1&amp;0&amp;1\end{array}\right]<br>$$</p>
<p>$$<br>sobel(垂直方向)&#x3D;\left[\begin{array}{c c c}1&amp;2&amp;1\ 0&amp;0&amp;0\ 1&amp;2&amp;1\end{array}\right]<br>$$</p>
<p>首先使用sobel算子计算中心像素点的两个方向上的梯度$G_{x}$和$G_{y}$，然后就能够得到其具体的梯度值：<br>$$<br>G&#x3D;{\sqrt{G_{x}{}^{2}+G_{y}{}^{2}}}<br>$$<br>也可以使用$G&#x3D;|G_{x}+G_{y}|$来代替。在OpenCV中，默认使用$G&#x3D;|G_{x}+G_{y}|$来计算梯度值。</p>
<p>然后我们根据如下公式可以得到一个角度值</p>
<p>​																						$${\frac{G_{\mathrm{y}}}{G_{x}}}&#x3D;\tan,(\theta)$$<br>$$<br>\theta&#x3D;\arctan,({\frac{G_{\mathrm{y}}}{G_{x}}})<br>$$<br><strong>这个角度值其实是当前边缘的梯度的方向</strong>。通过这个公式我们就可以计算出图片中所有的像素点的梯度值与梯度方向，然后根据梯度方向获取边缘的方向。</p>
<p>a). 并且如果梯度方向不是0°、45°、90°、135°这种特定角度，那么就要用到插值算法来计算当前像素点在其方向上进行插值的结果了，然后进行比较并判断是否保留该像素点。这里使用的是单线性插值，通过A1和A2两个像素点获得dTmp1与dTmp2处的插值，然后与中心点C进行比较(非极大值抑制)。具体的插值算法请参考图像旋转实验。</p>
<p>b). 得到$\theta$的值之后，就可以对边缘方向进行分类，为了简化计算过程,一般将其归为四个方向：水平方向、垂直方向、45°方向、135°方向。并且：</p>
<p>当$\theta$值为-22.5°~22.5°，或-157.5°~157.5°，则认为边缘为水平边缘；</p>
<p>当法线方向为22.5°~67.5°，或-112.5°~-157.5°，则认为边缘为45°边缘；</p>
<p>当法线方向为67.5°~112.5°，或-67.5°~-112.5°，则认为边缘为垂直边缘；</p>
<p>当法线方向为112.5°~157.5°，或-22.5°~-67.5°，则认为边缘为135°边缘；</p>
<h4 id="4-14-3-非极大值抑制"><a href="#4-14-3-非极大值抑制" class="headerlink" title="4.14.3 非极大值抑制"></a>4.14.3 非极大值抑制</h4><p>得到每个边缘的方向之后，其实把它们连起来边缘检测就算完了，但是为什么还有这一步与下一步呢？是因为经过第二步得到的边缘不经过处理是没办法使用的，因为高斯滤波的原因，边缘会变得模糊，导致经过第二步后得到的边缘像素点非常多，因此我们需要对其进行一些过滤操作，而非极大值抑制就是一个很好的方法，它会对得到的边缘像素进行一个排除，使边缘尽可能细一点。</p>
<p>在该步骤中，我们需要检查每个像素点的梯度方向上的相邻像素，并保留梯度值最大的像素，将其他像素抑制为零。假设当前像素点为（x，y），其梯度方向是0°，梯度值为G（x，y），那么我们就需要比较G（x，y）与两个相邻像素的梯度值：G（x-1，y）和G（x+1，y）。如果G（x，y）是三个值里面最大的，就保留该像素值，否则将其抑制为零。</p>
<h4 id="4-14-4代码用法"><a href="#4-14-4代码用法" class="headerlink" title="4.14.4代码用法"></a>4.14.4代码用法</h4><p>cv2.Canny(image, threshold1, threshold2)，</p>
<p>参数：图像，阈值1，阈值2</p>
<p>即使读到的是彩色图也可以进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#边缘检测</span><br><span class="line">img=cv.imread(&#x27;images/lvbo2.png&#x27;)</span><br><span class="line">ret,img_binary=cv.threshold(img,127,255,cv.THRESH_BINARY)</span><br><span class="line">img_ga=cv.GaussianBlur(img,(3,3),1)#作用：高斯模糊，作用：降噪</span><br><span class="line">ret,img_ga_binary=cv.threshold(img_ga,127,255,cv.THRESH_BINARY)</span><br><span class="line">dst_img=cv.Canny(img_binary,30,70)#参数：二值化后的图像，阈值1，阈值2</span><br><span class="line">dst_img_gau=cv.Canny(img_ga_binary,30,70)</span><br><span class="line">cv.imshow(&#x27;dst_img_gau&#x27;,dst_img_gau)</span><br><span class="line">cv.imshow(&#x27;dst_img&#x27;,dst_img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>



<h3 id="4-15绘制图像轮廓"><a href="#4-15绘制图像轮廓" class="headerlink" title="4.15绘制图像轮廓"></a>4.15绘制图像轮廓</h3><h4 id="4-15-1轮廓的定义"><a href="#4-15-1轮廓的定义" class="headerlink" title="4.15.1轮廓的定义"></a>4.15.1轮廓的定义</h4><p>- 轮廓是一系列连续的点和组成的曲线，代表了物体的基本外形。是一个闭合和封闭的图形</p>
<h4 id="4-15-2操作步骤"><a href="#4-15-2操作步骤" class="headerlink" title="4.15.2操作步骤"></a>4.15.2操作步骤</h4><p>1、先对图像进行预处理</p>
<p>转灰度，二值化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#绘制轮廓步骤，RETR_EXTERNAL 只绘制最外轮廓 存储中：CHAIN_APPROX_SIMPLE</span><br><span class="line">num_y=cv.imread(&quot;../images/num.png&quot;)</span><br><span class="line">#读图转灰度</span><br><span class="line">number=cv.imread(&quot;../images/num.png&quot;,cv.IMREAD_GRAYSCALE)</span><br><span class="line">#二值化</span><br><span class="line">_,num_t=cv.threshold(number,127,255,cv.THRESH_OTSU+cv.THRESH_BINARY_INV)</span><br></pre></td></tr></table></figure>

<p>2、关键操作：调用cv.findContours(目标图，找轮廓点的种类，保存方法）会返回两个值：轮廓坐标集合和层级结构</p>
<ul>
<li>常用的种类</li>
</ul>
<ol>
<li><strong>RETR_EXTERNAL</strong></li>
</ol>
<p>表示只查找最外层的轮廓。并且在hierarchy里的轮廓关系中，每一个轮廓只有前一条轮廓与后一条轮廓的索引，而没有父轮廓与子轮廓的索引。</p>
<p>2.3.4.会查找所有轮廓，但会有层级关系。</p>
<ol start="2">
<li><strong>RETR_LIST</strong></li>
</ol>
<p>表示列出所有的轮廓。并且在hierarchy里的轮廓关系中，每一个轮廓只有前一条轮廓与后一条轮廓的索引，而没有父轮廓与子轮廓的索引。</p>
<ol start="3">
<li><strong>RETR_CCOMP</strong></li>
</ol>
<p>表示列出所有的轮廓。并且在hierarchy里的轮廓关系中，轮廓会按照成对的方式显示。</p>
<p>在 <code>RETR_CCOMP</code> 模式下，轮廓被分为两个层级：</p>
<ul>
<li><strong>层级 0</strong>：所有外部轮廓（最外层的边界）。</li>
<li><strong>层级 1</strong>：所有内部轮廓（孔洞或嵌套的区域）。</li>
</ul>
<ol start="4">
<li><strong>RETR_TREE</strong></li>
</ol>
<p>表示列出所有的轮廓。并且在hierarchy里的轮廓关系中，轮廓会按照树的方式显示，其中最外层的轮廓作为树根，其子轮廓是一个个的树枝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查找轮廓</span><br><span class="line">contours,h=cv.findContours(num_t,mode=cv.RETR_EXTERNAL,method=cv.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure>

<p>绘制轮廓</p>
<p>使用cv.drawContours()将要绘制在什么图上，深度，所得的轮廓坐标列表，颜色，绘制线宽度依次传入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num=cv.drawContours(num_y,contours,-1,(0,0,255),2)</span><br></pre></td></tr></table></figure>

<p>显示图像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cv.imshow(&quot;num_t&quot;,num_t)  </span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h3 id="4-16绘制凸包"><a href="#4-16绘制凸包" class="headerlink" title="4.16绘制凸包"></a>4.16绘制凸包</h3><h4 id="4-16-1定义和方法"><a href="#4-16-1定义和方法" class="headerlink" title="4.16.1定义和方法"></a>4.16.1定义和方法</h4><p>在进行凸包特征检测之前，首先要了解什么是凸包。通俗的讲，凸包其实就是将一张图片中物体的最外层的点连接起来构成的凸多边形，它能包含物体中所有的内容。</p>
<p>一般来说，凸包都是伴随着某类点集存在的，也被称为某个点集的凸包。</p>
<p>对于一个点集来说，如果该点集存在凸包，那么这个点集里面的所有点要么在凸包上，要么在凸包内。</p>
<p>凸包检测常用在物体识别、手势识别、边界检测等领域。穷举法时间复杂度高不特殊情况不采用</p>
<ul>
<li>穷举法</li>
<li>QuickHull法</li>
</ul>
<h4 id="4-16-2quickhull法的代码实现步骤"><a href="#4-16-2quickhull法的代码实现步骤" class="headerlink" title="4.16.2quickhull法的代码实现步骤"></a>4.16.2quickhull法的代码实现步骤</h4><p>预处理灰度和二值化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#读图</span><br><span class="line">img=cv.imread(&#x27;../images/tu.png&#x27;)</span><br><span class="line"></span><br><span class="line">#转灰度</span><br><span class="line">img_g=cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">#二值化</span><br><span class="line">ret,img_b=cv.threshold(img_g,127,255,cv.THRESH_BINARY)</span><br></pre></td></tr></table></figure>

<p>查找轮廓</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查找轮廓</span><br><span class="line">ct,h=cv.findContours(img_b,cv.RETR_TREE,cv.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure>

<p>将凸包找出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#寻找凸包</span><br><span class="line">hull=cv.convexHull(ct[0])</span><br><span class="line">print(hull)</span><br></pre></td></tr></table></figure>

<p>绘制凸包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#绘制凸包</span><br><span class="line">cv.polylines(img,[hull],True,(0,255,0),1,cv.LINE_AA)</span><br><span class="line">#显示图像</span><br><span class="line">cv.imshow(&#x27;img&#x27;,img)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>4.17</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>CXZ</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://cxz-deman.github.io/2025/04/20/OpenCV%E5%A4%84%E7%90%86%E5%9B%BE%E5%83%8F/">https://cxz-deman.github.io/2025/04/20/OpenCV%E5%A4%84%E7%90%86%E5%9B%BE%E5%83%8F/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>god</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%90%88%E9%9B%86/"># 阶段学习笔记合集</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2025/03/30/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E6%96%B9%E5%BA%93/">常用的三方库</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© CXZ | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>